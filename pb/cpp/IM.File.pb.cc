// Generated by the protocol buffer compiler.  DO NOT EDIT!

#define INTERNAL_SUPPRESS_PROTOBUF_FIELD_DEPRECATION
#include "IM.File.pb.h"

#include <algorithm>

#include <google/protobuf/stubs/once.h>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/wire_format_lite_inl.h>
// @@protoc_insertion_point(includes)

namespace IM {
namespace File {

void protobuf_ShutdownFile_IM_2eFile_2eproto() {
  delete IMFileLoginReq::default_instance_;
  delete IMFileLoginRsp::default_instance_;
  delete IMFileState::default_instance_;
  delete IMFilePullDataReq::default_instance_;
  delete IMFilePullDataRsp::default_instance_;
  delete IMFileReq::default_instance_;
  delete IMFileRsp::default_instance_;
  delete IMFileNotify::default_instance_;
  delete IMFileHasOfflineReq::default_instance_;
  delete IMFileHasOfflineRsp::default_instance_;
  delete IMFileAddOfflineReq::default_instance_;
  delete IMFileDelOfflineReq::default_instance_;
}

void protobuf_AddDesc_IM_2eFile_2eproto() {
  static bool already_here = false;
  if (already_here) return;
  already_here = true;
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  ::IM::BaseDefine::protobuf_AddDesc_IM_2eBaseDefine_2eproto();
  IMFileLoginReq::default_instance_ = new IMFileLoginReq();
  IMFileLoginRsp::default_instance_ = new IMFileLoginRsp();
  IMFileState::default_instance_ = new IMFileState();
  IMFilePullDataReq::default_instance_ = new IMFilePullDataReq();
  IMFilePullDataRsp::default_instance_ = new IMFilePullDataRsp();
  IMFileReq::default_instance_ = new IMFileReq();
  IMFileRsp::default_instance_ = new IMFileRsp();
  IMFileNotify::default_instance_ = new IMFileNotify();
  IMFileHasOfflineReq::default_instance_ = new IMFileHasOfflineReq();
  IMFileHasOfflineRsp::default_instance_ = new IMFileHasOfflineRsp();
  IMFileAddOfflineReq::default_instance_ = new IMFileAddOfflineReq();
  IMFileDelOfflineReq::default_instance_ = new IMFileDelOfflineReq();
  IMFileLoginReq::default_instance_->InitAsDefaultInstance();
  IMFileLoginRsp::default_instance_->InitAsDefaultInstance();
  IMFileState::default_instance_->InitAsDefaultInstance();
  IMFilePullDataReq::default_instance_->InitAsDefaultInstance();
  IMFilePullDataRsp::default_instance_->InitAsDefaultInstance();
  IMFileReq::default_instance_->InitAsDefaultInstance();
  IMFileRsp::default_instance_->InitAsDefaultInstance();
  IMFileNotify::default_instance_->InitAsDefaultInstance();
  IMFileHasOfflineReq::default_instance_->InitAsDefaultInstance();
  IMFileHasOfflineRsp::default_instance_->InitAsDefaultInstance();
  IMFileAddOfflineReq::default_instance_->InitAsDefaultInstance();
  IMFileDelOfflineReq::default_instance_->InitAsDefaultInstance();
  ::google::protobuf::internal::OnShutdown(&protobuf_ShutdownFile_IM_2eFile_2eproto);
}

// Force AddDescriptors() to be called at static initialization time.
struct StaticDescriptorInitializer_IM_2eFile_2eproto {
  StaticDescriptorInitializer_IM_2eFile_2eproto() {
    protobuf_AddDesc_IM_2eFile_2eproto();
  }
} static_descriptor_initializer_IM_2eFile_2eproto_;


// ===================================================================

#ifndef _MSC_VER
const int IMFileLoginReq::kUserIdFieldNumber;
const int IMFileLoginReq::kTaskIdFieldNumber;
const int IMFileLoginReq::kFileRoleFieldNumber;
#endif  // !_MSC_VER

IMFileLoginReq::IMFileLoginReq()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void IMFileLoginReq::InitAsDefaultInstance() {
}

IMFileLoginReq::IMFileLoginReq(const IMFileLoginReq& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void IMFileLoginReq::SharedCtor() {
  _cached_size_ = 0;
  user_id_ = 0u;
  task_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  file_role_ = 1;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

IMFileLoginReq::~IMFileLoginReq() {
  SharedDtor();
}

void IMFileLoginReq::SharedDtor() {
  if (task_id_ != &::google::protobuf::internal::kEmptyString) {
    delete task_id_;
  }
  if (this != default_instance_) {
  }
}

void IMFileLoginReq::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const IMFileLoginReq& IMFileLoginReq::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_IM_2eFile_2eproto();  return *default_instance_;
}

IMFileLoginReq* IMFileLoginReq::default_instance_ = NULL;

IMFileLoginReq* IMFileLoginReq::New() const {
  return new IMFileLoginReq;
}

void IMFileLoginReq::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    user_id_ = 0u;
    if (has_task_id()) {
      if (task_id_ != &::google::protobuf::internal::kEmptyString) {
        task_id_->clear();
      }
    }
    file_role_ = 1;
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool IMFileLoginReq::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required uint32 user_id = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &user_id_)));
          set_has_user_id();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(18)) goto parse_task_id;
        break;
      }
      
      // required string task_id = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_task_id:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_task_id()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(24)) goto parse_file_role;
        break;
      }
      
      // required .IM.BaseDefine.ClientFileRole file_role = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_file_role:
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (IM::BaseDefine::ClientFileRole_IsValid(value)) {
            set_file_role(static_cast< IM::BaseDefine::ClientFileRole >(value));
          }
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }
      
      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void IMFileLoginReq::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required uint32 user_id = 1;
  if (has_user_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(1, this->user_id(), output);
  }
  
  // required string task_id = 2;
  if (has_task_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteString(
      2, this->task_id(), output);
  }
  
  // required .IM.BaseDefine.ClientFileRole file_role = 3;
  if (has_file_role()) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      3, this->file_role(), output);
  }
  
}

int IMFileLoginReq::ByteSize() const {
  int total_size = 0;
  
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required uint32 user_id = 1;
    if (has_user_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->user_id());
    }
    
    // required string task_id = 2;
    if (has_task_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->task_id());
    }
    
    // required .IM.BaseDefine.ClientFileRole file_role = 3;
    if (has_file_role()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::EnumSize(this->file_role());
    }
    
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void IMFileLoginReq::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const IMFileLoginReq*>(&from));
}

void IMFileLoginReq::MergeFrom(const IMFileLoginReq& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_user_id()) {
      set_user_id(from.user_id());
    }
    if (from.has_task_id()) {
      set_task_id(from.task_id());
    }
    if (from.has_file_role()) {
      set_file_role(from.file_role());
    }
  }
}

void IMFileLoginReq::CopyFrom(const IMFileLoginReq& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool IMFileLoginReq::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000007) != 0x00000007) return false;
  
  return true;
}

void IMFileLoginReq::Swap(IMFileLoginReq* other) {
  if (other != this) {
    std::swap(user_id_, other->user_id_);
    std::swap(task_id_, other->task_id_);
    std::swap(file_role_, other->file_role_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string IMFileLoginReq::GetTypeName() const {
  return "IM.File.IMFileLoginReq";
}


// ===================================================================

#ifndef _MSC_VER
const int IMFileLoginRsp::kResultCodeFieldNumber;
const int IMFileLoginRsp::kTaskIdFieldNumber;
#endif  // !_MSC_VER

IMFileLoginRsp::IMFileLoginRsp()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void IMFileLoginRsp::InitAsDefaultInstance() {
}

IMFileLoginRsp::IMFileLoginRsp(const IMFileLoginRsp& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void IMFileLoginRsp::SharedCtor() {
  _cached_size_ = 0;
  result_code_ = 0u;
  task_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

IMFileLoginRsp::~IMFileLoginRsp() {
  SharedDtor();
}

void IMFileLoginRsp::SharedDtor() {
  if (task_id_ != &::google::protobuf::internal::kEmptyString) {
    delete task_id_;
  }
  if (this != default_instance_) {
  }
}

void IMFileLoginRsp::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const IMFileLoginRsp& IMFileLoginRsp::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_IM_2eFile_2eproto();  return *default_instance_;
}

IMFileLoginRsp* IMFileLoginRsp::default_instance_ = NULL;

IMFileLoginRsp* IMFileLoginRsp::New() const {
  return new IMFileLoginRsp;
}

void IMFileLoginRsp::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    result_code_ = 0u;
    if (has_task_id()) {
      if (task_id_ != &::google::protobuf::internal::kEmptyString) {
        task_id_->clear();
      }
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool IMFileLoginRsp::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required uint32 result_code = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &result_code_)));
          set_has_result_code();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(18)) goto parse_task_id;
        break;
      }
      
      // required string task_id = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_task_id:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_task_id()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }
      
      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void IMFileLoginRsp::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required uint32 result_code = 1;
  if (has_result_code()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(1, this->result_code(), output);
  }
  
  // required string task_id = 2;
  if (has_task_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteString(
      2, this->task_id(), output);
  }
  
}

int IMFileLoginRsp::ByteSize() const {
  int total_size = 0;
  
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required uint32 result_code = 1;
    if (has_result_code()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->result_code());
    }
    
    // required string task_id = 2;
    if (has_task_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->task_id());
    }
    
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void IMFileLoginRsp::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const IMFileLoginRsp*>(&from));
}

void IMFileLoginRsp::MergeFrom(const IMFileLoginRsp& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_result_code()) {
      set_result_code(from.result_code());
    }
    if (from.has_task_id()) {
      set_task_id(from.task_id());
    }
  }
}

void IMFileLoginRsp::CopyFrom(const IMFileLoginRsp& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool IMFileLoginRsp::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000003) != 0x00000003) return false;
  
  return true;
}

void IMFileLoginRsp::Swap(IMFileLoginRsp* other) {
  if (other != this) {
    std::swap(result_code_, other->result_code_);
    std::swap(task_id_, other->task_id_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string IMFileLoginRsp::GetTypeName() const {
  return "IM.File.IMFileLoginRsp";
}


// ===================================================================

#ifndef _MSC_VER
const int IMFileState::kStateFieldNumber;
const int IMFileState::kTaskIdFieldNumber;
const int IMFileState::kUserIdFieldNumber;
#endif  // !_MSC_VER

IMFileState::IMFileState()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void IMFileState::InitAsDefaultInstance() {
}

IMFileState::IMFileState(const IMFileState& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void IMFileState::SharedCtor() {
  _cached_size_ = 0;
  state_ = 0;
  task_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  user_id_ = 0u;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

IMFileState::~IMFileState() {
  SharedDtor();
}

void IMFileState::SharedDtor() {
  if (task_id_ != &::google::protobuf::internal::kEmptyString) {
    delete task_id_;
  }
  if (this != default_instance_) {
  }
}

void IMFileState::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const IMFileState& IMFileState::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_IM_2eFile_2eproto();  return *default_instance_;
}

IMFileState* IMFileState::default_instance_ = NULL;

IMFileState* IMFileState::New() const {
  return new IMFileState;
}

void IMFileState::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    state_ = 0;
    if (has_task_id()) {
      if (task_id_ != &::google::protobuf::internal::kEmptyString) {
        task_id_->clear();
      }
    }
    user_id_ = 0u;
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool IMFileState::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required .IM.BaseDefine.ClientFileState state = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (IM::BaseDefine::ClientFileState_IsValid(value)) {
            set_state(static_cast< IM::BaseDefine::ClientFileState >(value));
          }
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(18)) goto parse_task_id;
        break;
      }
      
      // required string task_id = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_task_id:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_task_id()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(24)) goto parse_user_id;
        break;
      }
      
      // required uint32 user_id = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_user_id:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &user_id_)));
          set_has_user_id();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }
      
      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void IMFileState::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required .IM.BaseDefine.ClientFileState state = 1;
  if (has_state()) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      1, this->state(), output);
  }
  
  // required string task_id = 2;
  if (has_task_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteString(
      2, this->task_id(), output);
  }
  
  // required uint32 user_id = 3;
  if (has_user_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(3, this->user_id(), output);
  }
  
}

int IMFileState::ByteSize() const {
  int total_size = 0;
  
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required .IM.BaseDefine.ClientFileState state = 1;
    if (has_state()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::EnumSize(this->state());
    }
    
    // required string task_id = 2;
    if (has_task_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->task_id());
    }
    
    // required uint32 user_id = 3;
    if (has_user_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->user_id());
    }
    
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void IMFileState::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const IMFileState*>(&from));
}

void IMFileState::MergeFrom(const IMFileState& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_state()) {
      set_state(from.state());
    }
    if (from.has_task_id()) {
      set_task_id(from.task_id());
    }
    if (from.has_user_id()) {
      set_user_id(from.user_id());
    }
  }
}

void IMFileState::CopyFrom(const IMFileState& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool IMFileState::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000007) != 0x00000007) return false;
  
  return true;
}

void IMFileState::Swap(IMFileState* other) {
  if (other != this) {
    std::swap(state_, other->state_);
    std::swap(task_id_, other->task_id_);
    std::swap(user_id_, other->user_id_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string IMFileState::GetTypeName() const {
  return "IM.File.IMFileState";
}


// ===================================================================

#ifndef _MSC_VER
const int IMFilePullDataReq::kTaskIdFieldNumber;
const int IMFilePullDataReq::kUserIdFieldNumber;
const int IMFilePullDataReq::kTransModeFieldNumber;
const int IMFilePullDataReq::kOffsetFieldNumber;
const int IMFilePullDataReq::kDataSizeFieldNumber;
#endif  // !_MSC_VER

IMFilePullDataReq::IMFilePullDataReq()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void IMFilePullDataReq::InitAsDefaultInstance() {
}

IMFilePullDataReq::IMFilePullDataReq(const IMFilePullDataReq& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void IMFilePullDataReq::SharedCtor() {
  _cached_size_ = 0;
  task_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  user_id_ = 0u;
  trans_mode_ = 1;
  offset_ = 0u;
  data_size_ = 0u;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

IMFilePullDataReq::~IMFilePullDataReq() {
  SharedDtor();
}

void IMFilePullDataReq::SharedDtor() {
  if (task_id_ != &::google::protobuf::internal::kEmptyString) {
    delete task_id_;
  }
  if (this != default_instance_) {
  }
}

void IMFilePullDataReq::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const IMFilePullDataReq& IMFilePullDataReq::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_IM_2eFile_2eproto();  return *default_instance_;
}

IMFilePullDataReq* IMFilePullDataReq::default_instance_ = NULL;

IMFilePullDataReq* IMFilePullDataReq::New() const {
  return new IMFilePullDataReq;
}

void IMFilePullDataReq::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (has_task_id()) {
      if (task_id_ != &::google::protobuf::internal::kEmptyString) {
        task_id_->clear();
      }
    }
    user_id_ = 0u;
    trans_mode_ = 1;
    offset_ = 0u;
    data_size_ = 0u;
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool IMFilePullDataReq::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required string task_id = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_task_id()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(16)) goto parse_user_id;
        break;
      }
      
      // required uint32 user_id = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_user_id:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &user_id_)));
          set_has_user_id();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(24)) goto parse_trans_mode;
        break;
      }
      
      // required .IM.BaseDefine.FileType trans_mode = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_trans_mode:
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (IM::BaseDefine::FileType_IsValid(value)) {
            set_trans_mode(static_cast< IM::BaseDefine::FileType >(value));
          }
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(32)) goto parse_offset;
        break;
      }
      
      // required uint32 offset = 4;
      case 4: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_offset:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &offset_)));
          set_has_offset();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(40)) goto parse_data_size;
        break;
      }
      
      // required uint32 data_size = 5;
      case 5: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_data_size:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &data_size_)));
          set_has_data_size();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }
      
      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void IMFilePullDataReq::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required string task_id = 1;
  if (has_task_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteString(
      1, this->task_id(), output);
  }
  
  // required uint32 user_id = 2;
  if (has_user_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(2, this->user_id(), output);
  }
  
  // required .IM.BaseDefine.FileType trans_mode = 3;
  if (has_trans_mode()) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      3, this->trans_mode(), output);
  }
  
  // required uint32 offset = 4;
  if (has_offset()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(4, this->offset(), output);
  }
  
  // required uint32 data_size = 5;
  if (has_data_size()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(5, this->data_size(), output);
  }
  
}

int IMFilePullDataReq::ByteSize() const {
  int total_size = 0;
  
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required string task_id = 1;
    if (has_task_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->task_id());
    }
    
    // required uint32 user_id = 2;
    if (has_user_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->user_id());
    }
    
    // required .IM.BaseDefine.FileType trans_mode = 3;
    if (has_trans_mode()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::EnumSize(this->trans_mode());
    }
    
    // required uint32 offset = 4;
    if (has_offset()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->offset());
    }
    
    // required uint32 data_size = 5;
    if (has_data_size()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->data_size());
    }
    
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void IMFilePullDataReq::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const IMFilePullDataReq*>(&from));
}

void IMFilePullDataReq::MergeFrom(const IMFilePullDataReq& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_task_id()) {
      set_task_id(from.task_id());
    }
    if (from.has_user_id()) {
      set_user_id(from.user_id());
    }
    if (from.has_trans_mode()) {
      set_trans_mode(from.trans_mode());
    }
    if (from.has_offset()) {
      set_offset(from.offset());
    }
    if (from.has_data_size()) {
      set_data_size(from.data_size());
    }
  }
}

void IMFilePullDataReq::CopyFrom(const IMFilePullDataReq& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool IMFilePullDataReq::IsInitialized() const {
  if ((_has_bits_[0] & 0x0000001f) != 0x0000001f) return false;
  
  return true;
}

void IMFilePullDataReq::Swap(IMFilePullDataReq* other) {
  if (other != this) {
    std::swap(task_id_, other->task_id_);
    std::swap(user_id_, other->user_id_);
    std::swap(trans_mode_, other->trans_mode_);
    std::swap(offset_, other->offset_);
    std::swap(data_size_, other->data_size_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string IMFilePullDataReq::GetTypeName() const {
  return "IM.File.IMFilePullDataReq";
}


// ===================================================================

#ifndef _MSC_VER
const int IMFilePullDataRsp::kResultCodeFieldNumber;
const int IMFilePullDataRsp::kTaskIdFieldNumber;
const int IMFilePullDataRsp::kUserIdFieldNumber;
const int IMFilePullDataRsp::kOffsetFieldNumber;
const int IMFilePullDataRsp::kDataFieldNumber;
#endif  // !_MSC_VER

IMFilePullDataRsp::IMFilePullDataRsp()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void IMFilePullDataRsp::InitAsDefaultInstance() {
}

IMFilePullDataRsp::IMFilePullDataRsp(const IMFilePullDataRsp& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void IMFilePullDataRsp::SharedCtor() {
  _cached_size_ = 0;
  result_code_ = 0u;
  task_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  user_id_ = 0u;
  offset_ = 0u;
  data_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

IMFilePullDataRsp::~IMFilePullDataRsp() {
  SharedDtor();
}

void IMFilePullDataRsp::SharedDtor() {
  if (task_id_ != &::google::protobuf::internal::kEmptyString) {
    delete task_id_;
  }
  if (data_ != &::google::protobuf::internal::kEmptyString) {
    delete data_;
  }
  if (this != default_instance_) {
  }
}

void IMFilePullDataRsp::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const IMFilePullDataRsp& IMFilePullDataRsp::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_IM_2eFile_2eproto();  return *default_instance_;
}

IMFilePullDataRsp* IMFilePullDataRsp::default_instance_ = NULL;

IMFilePullDataRsp* IMFilePullDataRsp::New() const {
  return new IMFilePullDataRsp;
}

void IMFilePullDataRsp::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    result_code_ = 0u;
    if (has_task_id()) {
      if (task_id_ != &::google::protobuf::internal::kEmptyString) {
        task_id_->clear();
      }
    }
    user_id_ = 0u;
    offset_ = 0u;
    if (has_data()) {
      if (data_ != &::google::protobuf::internal::kEmptyString) {
        data_->clear();
      }
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool IMFilePullDataRsp::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required uint32 result_code = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &result_code_)));
          set_has_result_code();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(18)) goto parse_task_id;
        break;
      }
      
      // required string task_id = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_task_id:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_task_id()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(24)) goto parse_user_id;
        break;
      }
      
      // required uint32 user_id = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_user_id:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &user_id_)));
          set_has_user_id();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(32)) goto parse_offset;
        break;
      }
      
      // required uint32 offset = 4;
      case 4: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_offset:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &offset_)));
          set_has_offset();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(42)) goto parse_data;
        break;
      }
      
      // required bytes data = 5;
      case 5: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_data:
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->mutable_data()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }
      
      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void IMFilePullDataRsp::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required uint32 result_code = 1;
  if (has_result_code()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(1, this->result_code(), output);
  }
  
  // required string task_id = 2;
  if (has_task_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteString(
      2, this->task_id(), output);
  }
  
  // required uint32 user_id = 3;
  if (has_user_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(3, this->user_id(), output);
  }
  
  // required uint32 offset = 4;
  if (has_offset()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(4, this->offset(), output);
  }
  
  // required bytes data = 5;
  if (has_data()) {
    ::google::protobuf::internal::WireFormatLite::WriteBytes(
      5, this->data(), output);
  }
  
}

int IMFilePullDataRsp::ByteSize() const {
  int total_size = 0;
  
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required uint32 result_code = 1;
    if (has_result_code()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->result_code());
    }
    
    // required string task_id = 2;
    if (has_task_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->task_id());
    }
    
    // required uint32 user_id = 3;
    if (has_user_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->user_id());
    }
    
    // required uint32 offset = 4;
    if (has_offset()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->offset());
    }
    
    // required bytes data = 5;
    if (has_data()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::BytesSize(
          this->data());
    }
    
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void IMFilePullDataRsp::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const IMFilePullDataRsp*>(&from));
}

void IMFilePullDataRsp::MergeFrom(const IMFilePullDataRsp& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_result_code()) {
      set_result_code(from.result_code());
    }
    if (from.has_task_id()) {
      set_task_id(from.task_id());
    }
    if (from.has_user_id()) {
      set_user_id(from.user_id());
    }
    if (from.has_offset()) {
      set_offset(from.offset());
    }
    if (from.has_data()) {
      set_data(from.data());
    }
  }
}

void IMFilePullDataRsp::CopyFrom(const IMFilePullDataRsp& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool IMFilePullDataRsp::IsInitialized() const {
  if ((_has_bits_[0] & 0x0000001f) != 0x0000001f) return false;
  
  return true;
}

void IMFilePullDataRsp::Swap(IMFilePullDataRsp* other) {
  if (other != this) {
    std::swap(result_code_, other->result_code_);
    std::swap(task_id_, other->task_id_);
    std::swap(user_id_, other->user_id_);
    std::swap(offset_, other->offset_);
    std::swap(data_, other->data_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string IMFilePullDataRsp::GetTypeName() const {
  return "IM.File.IMFilePullDataRsp";
}


// ===================================================================

#ifndef _MSC_VER
const int IMFileReq::kFromUserIdFieldNumber;
const int IMFileReq::kToUserIdFieldNumber;
const int IMFileReq::kFileNameFieldNumber;
const int IMFileReq::kFileSizeFieldNumber;
const int IMFileReq::kTransModeFieldNumber;
#endif  // !_MSC_VER

IMFileReq::IMFileReq()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void IMFileReq::InitAsDefaultInstance() {
}

IMFileReq::IMFileReq(const IMFileReq& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void IMFileReq::SharedCtor() {
  _cached_size_ = 0;
  from_user_id_ = 0u;
  to_user_id_ = 0u;
  file_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  file_size_ = 0u;
  trans_mode_ = 1;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

IMFileReq::~IMFileReq() {
  SharedDtor();
}

void IMFileReq::SharedDtor() {
  if (file_name_ != &::google::protobuf::internal::kEmptyString) {
    delete file_name_;
  }
  if (this != default_instance_) {
  }
}

void IMFileReq::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const IMFileReq& IMFileReq::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_IM_2eFile_2eproto();  return *default_instance_;
}

IMFileReq* IMFileReq::default_instance_ = NULL;

IMFileReq* IMFileReq::New() const {
  return new IMFileReq;
}

void IMFileReq::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    from_user_id_ = 0u;
    to_user_id_ = 0u;
    if (has_file_name()) {
      if (file_name_ != &::google::protobuf::internal::kEmptyString) {
        file_name_->clear();
      }
    }
    file_size_ = 0u;
    trans_mode_ = 1;
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool IMFileReq::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required uint32 from_user_id = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &from_user_id_)));
          set_has_from_user_id();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(16)) goto parse_to_user_id;
        break;
      }
      
      // required uint32 to_user_id = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_to_user_id:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &to_user_id_)));
          set_has_to_user_id();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(26)) goto parse_file_name;
        break;
      }
      
      // required string file_name = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_file_name:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_file_name()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(32)) goto parse_file_size;
        break;
      }
      
      // required uint32 file_size = 4;
      case 4: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_file_size:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &file_size_)));
          set_has_file_size();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(40)) goto parse_trans_mode;
        break;
      }
      
      // required .IM.BaseDefine.FileType trans_mode = 5;
      case 5: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_trans_mode:
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (IM::BaseDefine::FileType_IsValid(value)) {
            set_trans_mode(static_cast< IM::BaseDefine::FileType >(value));
          }
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }
      
      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void IMFileReq::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required uint32 from_user_id = 1;
  if (has_from_user_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(1, this->from_user_id(), output);
  }
  
  // required uint32 to_user_id = 2;
  if (has_to_user_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(2, this->to_user_id(), output);
  }
  
  // required string file_name = 3;
  if (has_file_name()) {
    ::google::protobuf::internal::WireFormatLite::WriteString(
      3, this->file_name(), output);
  }
  
  // required uint32 file_size = 4;
  if (has_file_size()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(4, this->file_size(), output);
  }
  
  // required .IM.BaseDefine.FileType trans_mode = 5;
  if (has_trans_mode()) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      5, this->trans_mode(), output);
  }
  
}

int IMFileReq::ByteSize() const {
  int total_size = 0;
  
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required uint32 from_user_id = 1;
    if (has_from_user_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->from_user_id());
    }
    
    // required uint32 to_user_id = 2;
    if (has_to_user_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->to_user_id());
    }
    
    // required string file_name = 3;
    if (has_file_name()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->file_name());
    }
    
    // required uint32 file_size = 4;
    if (has_file_size()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->file_size());
    }
    
    // required .IM.BaseDefine.FileType trans_mode = 5;
    if (has_trans_mode()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::EnumSize(this->trans_mode());
    }
    
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void IMFileReq::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const IMFileReq*>(&from));
}

void IMFileReq::MergeFrom(const IMFileReq& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_from_user_id()) {
      set_from_user_id(from.from_user_id());
    }
    if (from.has_to_user_id()) {
      set_to_user_id(from.to_user_id());
    }
    if (from.has_file_name()) {
      set_file_name(from.file_name());
    }
    if (from.has_file_size()) {
      set_file_size(from.file_size());
    }
    if (from.has_trans_mode()) {
      set_trans_mode(from.trans_mode());
    }
  }
}

void IMFileReq::CopyFrom(const IMFileReq& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool IMFileReq::IsInitialized() const {
  if ((_has_bits_[0] & 0x0000001f) != 0x0000001f) return false;
  
  return true;
}

void IMFileReq::Swap(IMFileReq* other) {
  if (other != this) {
    std::swap(from_user_id_, other->from_user_id_);
    std::swap(to_user_id_, other->to_user_id_);
    std::swap(file_name_, other->file_name_);
    std::swap(file_size_, other->file_size_);
    std::swap(trans_mode_, other->trans_mode_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string IMFileReq::GetTypeName() const {
  return "IM.File.IMFileReq";
}


// ===================================================================

#ifndef _MSC_VER
const int IMFileRsp::kResultCodeFieldNumber;
const int IMFileRsp::kFromUserIdFieldNumber;
const int IMFileRsp::kToUserIdFieldNumber;
const int IMFileRsp::kFileNameFieldNumber;
const int IMFileRsp::kTaskIdFieldNumber;
const int IMFileRsp::kIpAddrListFieldNumber;
const int IMFileRsp::kTransModeFieldNumber;
#endif  // !_MSC_VER

IMFileRsp::IMFileRsp()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void IMFileRsp::InitAsDefaultInstance() {
}

IMFileRsp::IMFileRsp(const IMFileRsp& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void IMFileRsp::SharedCtor() {
  _cached_size_ = 0;
  result_code_ = 0u;
  from_user_id_ = 0u;
  to_user_id_ = 0u;
  file_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  task_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  trans_mode_ = 1;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

IMFileRsp::~IMFileRsp() {
  SharedDtor();
}

void IMFileRsp::SharedDtor() {
  if (file_name_ != &::google::protobuf::internal::kEmptyString) {
    delete file_name_;
  }
  if (task_id_ != &::google::protobuf::internal::kEmptyString) {
    delete task_id_;
  }
  if (this != default_instance_) {
  }
}

void IMFileRsp::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const IMFileRsp& IMFileRsp::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_IM_2eFile_2eproto();  return *default_instance_;
}

IMFileRsp* IMFileRsp::default_instance_ = NULL;

IMFileRsp* IMFileRsp::New() const {
  return new IMFileRsp;
}

void IMFileRsp::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    result_code_ = 0u;
    from_user_id_ = 0u;
    to_user_id_ = 0u;
    if (has_file_name()) {
      if (file_name_ != &::google::protobuf::internal::kEmptyString) {
        file_name_->clear();
      }
    }
    if (has_task_id()) {
      if (task_id_ != &::google::protobuf::internal::kEmptyString) {
        task_id_->clear();
      }
    }
    trans_mode_ = 1;
  }
  ip_addr_list_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool IMFileRsp::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required uint32 result_code = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &result_code_)));
          set_has_result_code();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(16)) goto parse_from_user_id;
        break;
      }
      
      // required uint32 from_user_id = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_from_user_id:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &from_user_id_)));
          set_has_from_user_id();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(24)) goto parse_to_user_id;
        break;
      }
      
      // required uint32 to_user_id = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_to_user_id:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &to_user_id_)));
          set_has_to_user_id();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(34)) goto parse_file_name;
        break;
      }
      
      // required string file_name = 4;
      case 4: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_file_name:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_file_name()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(42)) goto parse_task_id;
        break;
      }
      
      // required string task_id = 5;
      case 5: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_task_id:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_task_id()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(50)) goto parse_ip_addr_list;
        break;
      }
      
      // repeated .IM.BaseDefine.IpAddr ip_addr_list = 6;
      case 6: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_ip_addr_list:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_ip_addr_list()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(50)) goto parse_ip_addr_list;
        if (input->ExpectTag(56)) goto parse_trans_mode;
        break;
      }
      
      // required .IM.BaseDefine.FileType trans_mode = 7;
      case 7: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_trans_mode:
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (IM::BaseDefine::FileType_IsValid(value)) {
            set_trans_mode(static_cast< IM::BaseDefine::FileType >(value));
          }
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }
      
      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void IMFileRsp::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required uint32 result_code = 1;
  if (has_result_code()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(1, this->result_code(), output);
  }
  
  // required uint32 from_user_id = 2;
  if (has_from_user_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(2, this->from_user_id(), output);
  }
  
  // required uint32 to_user_id = 3;
  if (has_to_user_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(3, this->to_user_id(), output);
  }
  
  // required string file_name = 4;
  if (has_file_name()) {
    ::google::protobuf::internal::WireFormatLite::WriteString(
      4, this->file_name(), output);
  }
  
  // required string task_id = 5;
  if (has_task_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteString(
      5, this->task_id(), output);
  }
  
  // repeated .IM.BaseDefine.IpAddr ip_addr_list = 6;
  for (int i = 0; i < this->ip_addr_list_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      6, this->ip_addr_list(i), output);
  }
  
  // required .IM.BaseDefine.FileType trans_mode = 7;
  if (has_trans_mode()) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      7, this->trans_mode(), output);
  }
  
}

int IMFileRsp::ByteSize() const {
  int total_size = 0;
  
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required uint32 result_code = 1;
    if (has_result_code()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->result_code());
    }
    
    // required uint32 from_user_id = 2;
    if (has_from_user_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->from_user_id());
    }
    
    // required uint32 to_user_id = 3;
    if (has_to_user_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->to_user_id());
    }
    
    // required string file_name = 4;
    if (has_file_name()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->file_name());
    }
    
    // required string task_id = 5;
    if (has_task_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->task_id());
    }
    
    // required .IM.BaseDefine.FileType trans_mode = 7;
    if (has_trans_mode()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::EnumSize(this->trans_mode());
    }
    
  }
  // repeated .IM.BaseDefine.IpAddr ip_addr_list = 6;
  total_size += 1 * this->ip_addr_list_size();
  for (int i = 0; i < this->ip_addr_list_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->ip_addr_list(i));
  }
  
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void IMFileRsp::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const IMFileRsp*>(&from));
}

void IMFileRsp::MergeFrom(const IMFileRsp& from) {
  GOOGLE_CHECK_NE(&from, this);
  ip_addr_list_.MergeFrom(from.ip_addr_list_);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_result_code()) {
      set_result_code(from.result_code());
    }
    if (from.has_from_user_id()) {
      set_from_user_id(from.from_user_id());
    }
    if (from.has_to_user_id()) {
      set_to_user_id(from.to_user_id());
    }
    if (from.has_file_name()) {
      set_file_name(from.file_name());
    }
    if (from.has_task_id()) {
      set_task_id(from.task_id());
    }
    if (from.has_trans_mode()) {
      set_trans_mode(from.trans_mode());
    }
  }
}

void IMFileRsp::CopyFrom(const IMFileRsp& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool IMFileRsp::IsInitialized() const {
  if ((_has_bits_[0] & 0x0000005f) != 0x0000005f) return false;
  
  for (int i = 0; i < ip_addr_list_size(); i++) {
    if (!this->ip_addr_list(i).IsInitialized()) return false;
  }
  return true;
}

void IMFileRsp::Swap(IMFileRsp* other) {
  if (other != this) {
    std::swap(result_code_, other->result_code_);
    std::swap(from_user_id_, other->from_user_id_);
    std::swap(to_user_id_, other->to_user_id_);
    std::swap(file_name_, other->file_name_);
    std::swap(task_id_, other->task_id_);
    ip_addr_list_.Swap(&other->ip_addr_list_);
    std::swap(trans_mode_, other->trans_mode_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string IMFileRsp::GetTypeName() const {
  return "IM.File.IMFileRsp";
}


// ===================================================================

#ifndef _MSC_VER
const int IMFileNotify::kFromUserIdFieldNumber;
const int IMFileNotify::kToUserIdFieldNumber;
const int IMFileNotify::kFileNameFieldNumber;
const int IMFileNotify::kFileSizeFieldNumber;
const int IMFileNotify::kTaskIdFieldNumber;
const int IMFileNotify::kIpAddrListFieldNumber;
const int IMFileNotify::kTransModeFieldNumber;
const int IMFileNotify::kOfflineReadyFieldNumber;
#endif  // !_MSC_VER

IMFileNotify::IMFileNotify()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void IMFileNotify::InitAsDefaultInstance() {
}

IMFileNotify::IMFileNotify(const IMFileNotify& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void IMFileNotify::SharedCtor() {
  _cached_size_ = 0;
  from_user_id_ = 0u;
  to_user_id_ = 0u;
  file_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  file_size_ = 0u;
  task_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  trans_mode_ = 1;
  offline_ready_ = 0u;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

IMFileNotify::~IMFileNotify() {
  SharedDtor();
}

void IMFileNotify::SharedDtor() {
  if (file_name_ != &::google::protobuf::internal::kEmptyString) {
    delete file_name_;
  }
  if (task_id_ != &::google::protobuf::internal::kEmptyString) {
    delete task_id_;
  }
  if (this != default_instance_) {
  }
}

void IMFileNotify::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const IMFileNotify& IMFileNotify::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_IM_2eFile_2eproto();  return *default_instance_;
}

IMFileNotify* IMFileNotify::default_instance_ = NULL;

IMFileNotify* IMFileNotify::New() const {
  return new IMFileNotify;
}

void IMFileNotify::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    from_user_id_ = 0u;
    to_user_id_ = 0u;
    if (has_file_name()) {
      if (file_name_ != &::google::protobuf::internal::kEmptyString) {
        file_name_->clear();
      }
    }
    file_size_ = 0u;
    if (has_task_id()) {
      if (task_id_ != &::google::protobuf::internal::kEmptyString) {
        task_id_->clear();
      }
    }
    trans_mode_ = 1;
    offline_ready_ = 0u;
  }
  ip_addr_list_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool IMFileNotify::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required uint32 from_user_id = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &from_user_id_)));
          set_has_from_user_id();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(16)) goto parse_to_user_id;
        break;
      }
      
      // required uint32 to_user_id = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_to_user_id:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &to_user_id_)));
          set_has_to_user_id();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(26)) goto parse_file_name;
        break;
      }
      
      // required string file_name = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_file_name:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_file_name()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(32)) goto parse_file_size;
        break;
      }
      
      // required uint32 file_size = 4;
      case 4: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_file_size:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &file_size_)));
          set_has_file_size();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(42)) goto parse_task_id;
        break;
      }
      
      // required string task_id = 5;
      case 5: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_task_id:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_task_id()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(50)) goto parse_ip_addr_list;
        break;
      }
      
      // repeated .IM.BaseDefine.IpAddr ip_addr_list = 6;
      case 6: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_ip_addr_list:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_ip_addr_list()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(50)) goto parse_ip_addr_list;
        if (input->ExpectTag(56)) goto parse_trans_mode;
        break;
      }
      
      // required .IM.BaseDefine.FileType trans_mode = 7;
      case 7: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_trans_mode:
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (IM::BaseDefine::FileType_IsValid(value)) {
            set_trans_mode(static_cast< IM::BaseDefine::FileType >(value));
          }
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(64)) goto parse_offline_ready;
        break;
      }
      
      // required uint32 offline_ready = 8;
      case 8: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_offline_ready:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &offline_ready_)));
          set_has_offline_ready();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }
      
      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void IMFileNotify::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required uint32 from_user_id = 1;
  if (has_from_user_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(1, this->from_user_id(), output);
  }
  
  // required uint32 to_user_id = 2;
  if (has_to_user_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(2, this->to_user_id(), output);
  }
  
  // required string file_name = 3;
  if (has_file_name()) {
    ::google::protobuf::internal::WireFormatLite::WriteString(
      3, this->file_name(), output);
  }
  
  // required uint32 file_size = 4;
  if (has_file_size()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(4, this->file_size(), output);
  }
  
  // required string task_id = 5;
  if (has_task_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteString(
      5, this->task_id(), output);
  }
  
  // repeated .IM.BaseDefine.IpAddr ip_addr_list = 6;
  for (int i = 0; i < this->ip_addr_list_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      6, this->ip_addr_list(i), output);
  }
  
  // required .IM.BaseDefine.FileType trans_mode = 7;
  if (has_trans_mode()) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      7, this->trans_mode(), output);
  }
  
  // required uint32 offline_ready = 8;
  if (has_offline_ready()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(8, this->offline_ready(), output);
  }
  
}

int IMFileNotify::ByteSize() const {
  int total_size = 0;
  
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required uint32 from_user_id = 1;
    if (has_from_user_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->from_user_id());
    }
    
    // required uint32 to_user_id = 2;
    if (has_to_user_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->to_user_id());
    }
    
    // required string file_name = 3;
    if (has_file_name()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->file_name());
    }
    
    // required uint32 file_size = 4;
    if (has_file_size()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->file_size());
    }
    
    // required string task_id = 5;
    if (has_task_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->task_id());
    }
    
    // required .IM.BaseDefine.FileType trans_mode = 7;
    if (has_trans_mode()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::EnumSize(this->trans_mode());
    }
    
    // required uint32 offline_ready = 8;
    if (has_offline_ready()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->offline_ready());
    }
    
  }
  // repeated .IM.BaseDefine.IpAddr ip_addr_list = 6;
  total_size += 1 * this->ip_addr_list_size();
  for (int i = 0; i < this->ip_addr_list_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->ip_addr_list(i));
  }
  
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void IMFileNotify::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const IMFileNotify*>(&from));
}

void IMFileNotify::MergeFrom(const IMFileNotify& from) {
  GOOGLE_CHECK_NE(&from, this);
  ip_addr_list_.MergeFrom(from.ip_addr_list_);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_from_user_id()) {
      set_from_user_id(from.from_user_id());
    }
    if (from.has_to_user_id()) {
      set_to_user_id(from.to_user_id());
    }
    if (from.has_file_name()) {
      set_file_name(from.file_name());
    }
    if (from.has_file_size()) {
      set_file_size(from.file_size());
    }
    if (from.has_task_id()) {
      set_task_id(from.task_id());
    }
    if (from.has_trans_mode()) {
      set_trans_mode(from.trans_mode());
    }
    if (from.has_offline_ready()) {
      set_offline_ready(from.offline_ready());
    }
  }
}

void IMFileNotify::CopyFrom(const IMFileNotify& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool IMFileNotify::IsInitialized() const {
  if ((_has_bits_[0] & 0x000000df) != 0x000000df) return false;
  
  for (int i = 0; i < ip_addr_list_size(); i++) {
    if (!this->ip_addr_list(i).IsInitialized()) return false;
  }
  return true;
}

void IMFileNotify::Swap(IMFileNotify* other) {
  if (other != this) {
    std::swap(from_user_id_, other->from_user_id_);
    std::swap(to_user_id_, other->to_user_id_);
    std::swap(file_name_, other->file_name_);
    std::swap(file_size_, other->file_size_);
    std::swap(task_id_, other->task_id_);
    ip_addr_list_.Swap(&other->ip_addr_list_);
    std::swap(trans_mode_, other->trans_mode_);
    std::swap(offline_ready_, other->offline_ready_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string IMFileNotify::GetTypeName() const {
  return "IM.File.IMFileNotify";
}


// ===================================================================

#ifndef _MSC_VER
const int IMFileHasOfflineReq::kUserIdFieldNumber;
const int IMFileHasOfflineReq::kAttachDataFieldNumber;
#endif  // !_MSC_VER

IMFileHasOfflineReq::IMFileHasOfflineReq()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void IMFileHasOfflineReq::InitAsDefaultInstance() {
}

IMFileHasOfflineReq::IMFileHasOfflineReq(const IMFileHasOfflineReq& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void IMFileHasOfflineReq::SharedCtor() {
  _cached_size_ = 0;
  user_id_ = 0u;
  attach_data_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

IMFileHasOfflineReq::~IMFileHasOfflineReq() {
  SharedDtor();
}

void IMFileHasOfflineReq::SharedDtor() {
  if (attach_data_ != &::google::protobuf::internal::kEmptyString) {
    delete attach_data_;
  }
  if (this != default_instance_) {
  }
}

void IMFileHasOfflineReq::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const IMFileHasOfflineReq& IMFileHasOfflineReq::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_IM_2eFile_2eproto();  return *default_instance_;
}

IMFileHasOfflineReq* IMFileHasOfflineReq::default_instance_ = NULL;

IMFileHasOfflineReq* IMFileHasOfflineReq::New() const {
  return new IMFileHasOfflineReq;
}

void IMFileHasOfflineReq::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    user_id_ = 0u;
    if (has_attach_data()) {
      if (attach_data_ != &::google::protobuf::internal::kEmptyString) {
        attach_data_->clear();
      }
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool IMFileHasOfflineReq::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required uint32 user_id = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &user_id_)));
          set_has_user_id();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(162)) goto parse_attach_data;
        break;
      }
      
      // optional bytes attach_data = 20;
      case 20: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_attach_data:
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->mutable_attach_data()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }
      
      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void IMFileHasOfflineReq::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required uint32 user_id = 1;
  if (has_user_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(1, this->user_id(), output);
  }
  
  // optional bytes attach_data = 20;
  if (has_attach_data()) {
    ::google::protobuf::internal::WireFormatLite::WriteBytes(
      20, this->attach_data(), output);
  }
  
}

int IMFileHasOfflineReq::ByteSize() const {
  int total_size = 0;
  
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required uint32 user_id = 1;
    if (has_user_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->user_id());
    }
    
    // optional bytes attach_data = 20;
    if (has_attach_data()) {
      total_size += 2 +
        ::google::protobuf::internal::WireFormatLite::BytesSize(
          this->attach_data());
    }
    
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void IMFileHasOfflineReq::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const IMFileHasOfflineReq*>(&from));
}

void IMFileHasOfflineReq::MergeFrom(const IMFileHasOfflineReq& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_user_id()) {
      set_user_id(from.user_id());
    }
    if (from.has_attach_data()) {
      set_attach_data(from.attach_data());
    }
  }
}

void IMFileHasOfflineReq::CopyFrom(const IMFileHasOfflineReq& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool IMFileHasOfflineReq::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;
  
  return true;
}

void IMFileHasOfflineReq::Swap(IMFileHasOfflineReq* other) {
  if (other != this) {
    std::swap(user_id_, other->user_id_);
    std::swap(attach_data_, other->attach_data_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string IMFileHasOfflineReq::GetTypeName() const {
  return "IM.File.IMFileHasOfflineReq";
}


// ===================================================================

#ifndef _MSC_VER
const int IMFileHasOfflineRsp::kUserIdFieldNumber;
const int IMFileHasOfflineRsp::kOfflineFileListFieldNumber;
const int IMFileHasOfflineRsp::kIpAddrListFieldNumber;
const int IMFileHasOfflineRsp::kAttachDataFieldNumber;
#endif  // !_MSC_VER

IMFileHasOfflineRsp::IMFileHasOfflineRsp()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void IMFileHasOfflineRsp::InitAsDefaultInstance() {
}

IMFileHasOfflineRsp::IMFileHasOfflineRsp(const IMFileHasOfflineRsp& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void IMFileHasOfflineRsp::SharedCtor() {
  _cached_size_ = 0;
  user_id_ = 0u;
  attach_data_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

IMFileHasOfflineRsp::~IMFileHasOfflineRsp() {
  SharedDtor();
}

void IMFileHasOfflineRsp::SharedDtor() {
  if (attach_data_ != &::google::protobuf::internal::kEmptyString) {
    delete attach_data_;
  }
  if (this != default_instance_) {
  }
}

void IMFileHasOfflineRsp::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const IMFileHasOfflineRsp& IMFileHasOfflineRsp::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_IM_2eFile_2eproto();  return *default_instance_;
}

IMFileHasOfflineRsp* IMFileHasOfflineRsp::default_instance_ = NULL;

IMFileHasOfflineRsp* IMFileHasOfflineRsp::New() const {
  return new IMFileHasOfflineRsp;
}

void IMFileHasOfflineRsp::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    user_id_ = 0u;
    if (has_attach_data()) {
      if (attach_data_ != &::google::protobuf::internal::kEmptyString) {
        attach_data_->clear();
      }
    }
  }
  offline_file_list_.Clear();
  ip_addr_list_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool IMFileHasOfflineRsp::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required uint32 user_id = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &user_id_)));
          set_has_user_id();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(18)) goto parse_offline_file_list;
        break;
      }
      
      // repeated .IM.BaseDefine.OfflineFileInfo offline_file_list = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_offline_file_list:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_offline_file_list()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(18)) goto parse_offline_file_list;
        if (input->ExpectTag(26)) goto parse_ip_addr_list;
        break;
      }
      
      // repeated .IM.BaseDefine.IpAddr ip_addr_list = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_ip_addr_list:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_ip_addr_list()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(26)) goto parse_ip_addr_list;
        if (input->ExpectTag(162)) goto parse_attach_data;
        break;
      }
      
      // optional bytes attach_data = 20;
      case 20: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_attach_data:
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->mutable_attach_data()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }
      
      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void IMFileHasOfflineRsp::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required uint32 user_id = 1;
  if (has_user_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(1, this->user_id(), output);
  }
  
  // repeated .IM.BaseDefine.OfflineFileInfo offline_file_list = 2;
  for (int i = 0; i < this->offline_file_list_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      2, this->offline_file_list(i), output);
  }
  
  // repeated .IM.BaseDefine.IpAddr ip_addr_list = 3;
  for (int i = 0; i < this->ip_addr_list_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      3, this->ip_addr_list(i), output);
  }
  
  // optional bytes attach_data = 20;
  if (has_attach_data()) {
    ::google::protobuf::internal::WireFormatLite::WriteBytes(
      20, this->attach_data(), output);
  }
  
}

int IMFileHasOfflineRsp::ByteSize() const {
  int total_size = 0;
  
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required uint32 user_id = 1;
    if (has_user_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->user_id());
    }
    
    // optional bytes attach_data = 20;
    if (has_attach_data()) {
      total_size += 2 +
        ::google::protobuf::internal::WireFormatLite::BytesSize(
          this->attach_data());
    }
    
  }
  // repeated .IM.BaseDefine.OfflineFileInfo offline_file_list = 2;
  total_size += 1 * this->offline_file_list_size();
  for (int i = 0; i < this->offline_file_list_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->offline_file_list(i));
  }
  
  // repeated .IM.BaseDefine.IpAddr ip_addr_list = 3;
  total_size += 1 * this->ip_addr_list_size();
  for (int i = 0; i < this->ip_addr_list_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->ip_addr_list(i));
  }
  
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void IMFileHasOfflineRsp::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const IMFileHasOfflineRsp*>(&from));
}

void IMFileHasOfflineRsp::MergeFrom(const IMFileHasOfflineRsp& from) {
  GOOGLE_CHECK_NE(&from, this);
  offline_file_list_.MergeFrom(from.offline_file_list_);
  ip_addr_list_.MergeFrom(from.ip_addr_list_);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_user_id()) {
      set_user_id(from.user_id());
    }
    if (from.has_attach_data()) {
      set_attach_data(from.attach_data());
    }
  }
}

void IMFileHasOfflineRsp::CopyFrom(const IMFileHasOfflineRsp& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool IMFileHasOfflineRsp::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;
  
  for (int i = 0; i < offline_file_list_size(); i++) {
    if (!this->offline_file_list(i).IsInitialized()) return false;
  }
  for (int i = 0; i < ip_addr_list_size(); i++) {
    if (!this->ip_addr_list(i).IsInitialized()) return false;
  }
  return true;
}

void IMFileHasOfflineRsp::Swap(IMFileHasOfflineRsp* other) {
  if (other != this) {
    std::swap(user_id_, other->user_id_);
    offline_file_list_.Swap(&other->offline_file_list_);
    ip_addr_list_.Swap(&other->ip_addr_list_);
    std::swap(attach_data_, other->attach_data_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string IMFileHasOfflineRsp::GetTypeName() const {
  return "IM.File.IMFileHasOfflineRsp";
}


// ===================================================================

#ifndef _MSC_VER
const int IMFileAddOfflineReq::kFromUserIdFieldNumber;
const int IMFileAddOfflineReq::kToUserIdFieldNumber;
const int IMFileAddOfflineReq::kTaskIdFieldNumber;
const int IMFileAddOfflineReq::kFileNameFieldNumber;
const int IMFileAddOfflineReq::kFileSizeFieldNumber;
#endif  // !_MSC_VER

IMFileAddOfflineReq::IMFileAddOfflineReq()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void IMFileAddOfflineReq::InitAsDefaultInstance() {
}

IMFileAddOfflineReq::IMFileAddOfflineReq(const IMFileAddOfflineReq& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void IMFileAddOfflineReq::SharedCtor() {
  _cached_size_ = 0;
  from_user_id_ = 0u;
  to_user_id_ = 0u;
  task_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  file_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  file_size_ = 0u;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

IMFileAddOfflineReq::~IMFileAddOfflineReq() {
  SharedDtor();
}

void IMFileAddOfflineReq::SharedDtor() {
  if (task_id_ != &::google::protobuf::internal::kEmptyString) {
    delete task_id_;
  }
  if (file_name_ != &::google::protobuf::internal::kEmptyString) {
    delete file_name_;
  }
  if (this != default_instance_) {
  }
}

void IMFileAddOfflineReq::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const IMFileAddOfflineReq& IMFileAddOfflineReq::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_IM_2eFile_2eproto();  return *default_instance_;
}

IMFileAddOfflineReq* IMFileAddOfflineReq::default_instance_ = NULL;

IMFileAddOfflineReq* IMFileAddOfflineReq::New() const {
  return new IMFileAddOfflineReq;
}

void IMFileAddOfflineReq::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    from_user_id_ = 0u;
    to_user_id_ = 0u;
    if (has_task_id()) {
      if (task_id_ != &::google::protobuf::internal::kEmptyString) {
        task_id_->clear();
      }
    }
    if (has_file_name()) {
      if (file_name_ != &::google::protobuf::internal::kEmptyString) {
        file_name_->clear();
      }
    }
    file_size_ = 0u;
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool IMFileAddOfflineReq::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required uint32 from_user_id = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &from_user_id_)));
          set_has_from_user_id();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(16)) goto parse_to_user_id;
        break;
      }
      
      // required uint32 to_user_id = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_to_user_id:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &to_user_id_)));
          set_has_to_user_id();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(26)) goto parse_task_id;
        break;
      }
      
      // required string task_id = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_task_id:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_task_id()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(34)) goto parse_file_name;
        break;
      }
      
      // required string file_name = 4;
      case 4: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_file_name:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_file_name()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(40)) goto parse_file_size;
        break;
      }
      
      // required uint32 file_size = 5;
      case 5: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_file_size:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &file_size_)));
          set_has_file_size();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }
      
      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void IMFileAddOfflineReq::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required uint32 from_user_id = 1;
  if (has_from_user_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(1, this->from_user_id(), output);
  }
  
  // required uint32 to_user_id = 2;
  if (has_to_user_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(2, this->to_user_id(), output);
  }
  
  // required string task_id = 3;
  if (has_task_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteString(
      3, this->task_id(), output);
  }
  
  // required string file_name = 4;
  if (has_file_name()) {
    ::google::protobuf::internal::WireFormatLite::WriteString(
      4, this->file_name(), output);
  }
  
  // required uint32 file_size = 5;
  if (has_file_size()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(5, this->file_size(), output);
  }
  
}

int IMFileAddOfflineReq::ByteSize() const {
  int total_size = 0;
  
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required uint32 from_user_id = 1;
    if (has_from_user_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->from_user_id());
    }
    
    // required uint32 to_user_id = 2;
    if (has_to_user_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->to_user_id());
    }
    
    // required string task_id = 3;
    if (has_task_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->task_id());
    }
    
    // required string file_name = 4;
    if (has_file_name()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->file_name());
    }
    
    // required uint32 file_size = 5;
    if (has_file_size()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->file_size());
    }
    
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void IMFileAddOfflineReq::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const IMFileAddOfflineReq*>(&from));
}

void IMFileAddOfflineReq::MergeFrom(const IMFileAddOfflineReq& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_from_user_id()) {
      set_from_user_id(from.from_user_id());
    }
    if (from.has_to_user_id()) {
      set_to_user_id(from.to_user_id());
    }
    if (from.has_task_id()) {
      set_task_id(from.task_id());
    }
    if (from.has_file_name()) {
      set_file_name(from.file_name());
    }
    if (from.has_file_size()) {
      set_file_size(from.file_size());
    }
  }
}

void IMFileAddOfflineReq::CopyFrom(const IMFileAddOfflineReq& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool IMFileAddOfflineReq::IsInitialized() const {
  if ((_has_bits_[0] & 0x0000001f) != 0x0000001f) return false;
  
  return true;
}

void IMFileAddOfflineReq::Swap(IMFileAddOfflineReq* other) {
  if (other != this) {
    std::swap(from_user_id_, other->from_user_id_);
    std::swap(to_user_id_, other->to_user_id_);
    std::swap(task_id_, other->task_id_);
    std::swap(file_name_, other->file_name_);
    std::swap(file_size_, other->file_size_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string IMFileAddOfflineReq::GetTypeName() const {
  return "IM.File.IMFileAddOfflineReq";
}


// ===================================================================

#ifndef _MSC_VER
const int IMFileDelOfflineReq::kFromUserIdFieldNumber;
const int IMFileDelOfflineReq::kToUserIdFieldNumber;
const int IMFileDelOfflineReq::kTaskIdFieldNumber;
#endif  // !_MSC_VER

IMFileDelOfflineReq::IMFileDelOfflineReq()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void IMFileDelOfflineReq::InitAsDefaultInstance() {
}

IMFileDelOfflineReq::IMFileDelOfflineReq(const IMFileDelOfflineReq& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void IMFileDelOfflineReq::SharedCtor() {
  _cached_size_ = 0;
  from_user_id_ = 0u;
  to_user_id_ = 0u;
  task_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

IMFileDelOfflineReq::~IMFileDelOfflineReq() {
  SharedDtor();
}

void IMFileDelOfflineReq::SharedDtor() {
  if (task_id_ != &::google::protobuf::internal::kEmptyString) {
    delete task_id_;
  }
  if (this != default_instance_) {
  }
}

void IMFileDelOfflineReq::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const IMFileDelOfflineReq& IMFileDelOfflineReq::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_IM_2eFile_2eproto();  return *default_instance_;
}

IMFileDelOfflineReq* IMFileDelOfflineReq::default_instance_ = NULL;

IMFileDelOfflineReq* IMFileDelOfflineReq::New() const {
  return new IMFileDelOfflineReq;
}

void IMFileDelOfflineReq::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    from_user_id_ = 0u;
    to_user_id_ = 0u;
    if (has_task_id()) {
      if (task_id_ != &::google::protobuf::internal::kEmptyString) {
        task_id_->clear();
      }
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool IMFileDelOfflineReq::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required uint32 from_user_id = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &from_user_id_)));
          set_has_from_user_id();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(16)) goto parse_to_user_id;
        break;
      }
      
      // required uint32 to_user_id = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_to_user_id:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &to_user_id_)));
          set_has_to_user_id();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(26)) goto parse_task_id;
        break;
      }
      
      // required string task_id = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_task_id:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_task_id()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }
      
      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void IMFileDelOfflineReq::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required uint32 from_user_id = 1;
  if (has_from_user_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(1, this->from_user_id(), output);
  }
  
  // required uint32 to_user_id = 2;
  if (has_to_user_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(2, this->to_user_id(), output);
  }
  
  // required string task_id = 3;
  if (has_task_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteString(
      3, this->task_id(), output);
  }
  
}

int IMFileDelOfflineReq::ByteSize() const {
  int total_size = 0;
  
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required uint32 from_user_id = 1;
    if (has_from_user_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->from_user_id());
    }
    
    // required uint32 to_user_id = 2;
    if (has_to_user_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->to_user_id());
    }
    
    // required string task_id = 3;
    if (has_task_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->task_id());
    }
    
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void IMFileDelOfflineReq::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const IMFileDelOfflineReq*>(&from));
}

void IMFileDelOfflineReq::MergeFrom(const IMFileDelOfflineReq& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_from_user_id()) {
      set_from_user_id(from.from_user_id());
    }
    if (from.has_to_user_id()) {
      set_to_user_id(from.to_user_id());
    }
    if (from.has_task_id()) {
      set_task_id(from.task_id());
    }
  }
}

void IMFileDelOfflineReq::CopyFrom(const IMFileDelOfflineReq& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool IMFileDelOfflineReq::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000007) != 0x00000007) return false;
  
  return true;
}

void IMFileDelOfflineReq::Swap(IMFileDelOfflineReq* other) {
  if (other != this) {
    std::swap(from_user_id_, other->from_user_id_);
    std::swap(to_user_id_, other->to_user_id_);
    std::swap(task_id_, other->task_id_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string IMFileDelOfflineReq::GetTypeName() const {
  return "IM.File.IMFileDelOfflineReq";
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace File
}  // namespace IM

// @@protoc_insertion_point(global_scope)
