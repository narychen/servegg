// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: IM.File.proto

#ifndef PROTOBUF_IM_2eFile_2eproto__INCLUDED
#define PROTOBUF_IM_2eFile_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2004000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2004001 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include "IM.BaseDefine.pb.h"
// @@protoc_insertion_point(includes)

namespace IM {
namespace File {

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_IM_2eFile_2eproto();
void protobuf_AssignDesc_IM_2eFile_2eproto();
void protobuf_ShutdownFile_IM_2eFile_2eproto();

class IMFileLoginReq;
class IMFileLoginRsp;
class IMFileState;
class IMFilePullDataReq;
class IMFilePullDataRsp;
class IMFileReq;
class IMFileRsp;
class IMFileNotify;
class IMFileHasOfflineReq;
class IMFileHasOfflineRsp;
class IMFileAddOfflineReq;
class IMFileDelOfflineReq;

// ===================================================================

class IMFileLoginReq : public ::google::protobuf::MessageLite {
 public:
  IMFileLoginReq();
  virtual ~IMFileLoginReq();
  
  IMFileLoginReq(const IMFileLoginReq& from);
  
  inline IMFileLoginReq& operator=(const IMFileLoginReq& from) {
    CopyFrom(from);
    return *this;
  }
  
  static const IMFileLoginReq& default_instance();
  
  void Swap(IMFileLoginReq* other);
  
  // implements Message ----------------------------------------------
  
  IMFileLoginReq* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const IMFileLoginReq& from);
  void MergeFrom(const IMFileLoginReq& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::std::string GetTypeName() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required uint32 user_id = 1;
  inline bool has_user_id() const;
  inline void clear_user_id();
  static const int kUserIdFieldNumber = 1;
  inline ::google::protobuf::uint32 user_id() const;
  inline void set_user_id(::google::protobuf::uint32 value);
  
  // required string task_id = 2;
  inline bool has_task_id() const;
  inline void clear_task_id();
  static const int kTaskIdFieldNumber = 2;
  inline const ::std::string& task_id() const;
  inline void set_task_id(const ::std::string& value);
  inline void set_task_id(const char* value);
  inline void set_task_id(const char* value, size_t size);
  inline ::std::string* mutable_task_id();
  inline ::std::string* release_task_id();
  
  // required .IM.BaseDefine.ClientFileRole file_role = 3;
  inline bool has_file_role() const;
  inline void clear_file_role();
  static const int kFileRoleFieldNumber = 3;
  inline IM::BaseDefine::ClientFileRole file_role() const;
  inline void set_file_role(IM::BaseDefine::ClientFileRole value);
  
  // @@protoc_insertion_point(class_scope:IM.File.IMFileLoginReq)
 private:
  inline void set_has_user_id();
  inline void clear_has_user_id();
  inline void set_has_task_id();
  inline void clear_has_task_id();
  inline void set_has_file_role();
  inline void clear_has_file_role();
  
  ::std::string* task_id_;
  ::google::protobuf::uint32 user_id_;
  int file_role_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];
  
  friend void  protobuf_AddDesc_IM_2eFile_2eproto();
  friend void protobuf_AssignDesc_IM_2eFile_2eproto();
  friend void protobuf_ShutdownFile_IM_2eFile_2eproto();
  
  void InitAsDefaultInstance();
  static IMFileLoginReq* default_instance_;
};
// -------------------------------------------------------------------

class IMFileLoginRsp : public ::google::protobuf::MessageLite {
 public:
  IMFileLoginRsp();
  virtual ~IMFileLoginRsp();
  
  IMFileLoginRsp(const IMFileLoginRsp& from);
  
  inline IMFileLoginRsp& operator=(const IMFileLoginRsp& from) {
    CopyFrom(from);
    return *this;
  }
  
  static const IMFileLoginRsp& default_instance();
  
  void Swap(IMFileLoginRsp* other);
  
  // implements Message ----------------------------------------------
  
  IMFileLoginRsp* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const IMFileLoginRsp& from);
  void MergeFrom(const IMFileLoginRsp& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::std::string GetTypeName() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required uint32 result_code = 1;
  inline bool has_result_code() const;
  inline void clear_result_code();
  static const int kResultCodeFieldNumber = 1;
  inline ::google::protobuf::uint32 result_code() const;
  inline void set_result_code(::google::protobuf::uint32 value);
  
  // required string task_id = 2;
  inline bool has_task_id() const;
  inline void clear_task_id();
  static const int kTaskIdFieldNumber = 2;
  inline const ::std::string& task_id() const;
  inline void set_task_id(const ::std::string& value);
  inline void set_task_id(const char* value);
  inline void set_task_id(const char* value, size_t size);
  inline ::std::string* mutable_task_id();
  inline ::std::string* release_task_id();
  
  // @@protoc_insertion_point(class_scope:IM.File.IMFileLoginRsp)
 private:
  inline void set_has_result_code();
  inline void clear_has_result_code();
  inline void set_has_task_id();
  inline void clear_has_task_id();
  
  ::std::string* task_id_;
  ::google::protobuf::uint32 result_code_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];
  
  friend void  protobuf_AddDesc_IM_2eFile_2eproto();
  friend void protobuf_AssignDesc_IM_2eFile_2eproto();
  friend void protobuf_ShutdownFile_IM_2eFile_2eproto();
  
  void InitAsDefaultInstance();
  static IMFileLoginRsp* default_instance_;
};
// -------------------------------------------------------------------

class IMFileState : public ::google::protobuf::MessageLite {
 public:
  IMFileState();
  virtual ~IMFileState();
  
  IMFileState(const IMFileState& from);
  
  inline IMFileState& operator=(const IMFileState& from) {
    CopyFrom(from);
    return *this;
  }
  
  static const IMFileState& default_instance();
  
  void Swap(IMFileState* other);
  
  // implements Message ----------------------------------------------
  
  IMFileState* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const IMFileState& from);
  void MergeFrom(const IMFileState& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::std::string GetTypeName() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required .IM.BaseDefine.ClientFileState state = 1;
  inline bool has_state() const;
  inline void clear_state();
  static const int kStateFieldNumber = 1;
  inline IM::BaseDefine::ClientFileState state() const;
  inline void set_state(IM::BaseDefine::ClientFileState value);
  
  // required string task_id = 2;
  inline bool has_task_id() const;
  inline void clear_task_id();
  static const int kTaskIdFieldNumber = 2;
  inline const ::std::string& task_id() const;
  inline void set_task_id(const ::std::string& value);
  inline void set_task_id(const char* value);
  inline void set_task_id(const char* value, size_t size);
  inline ::std::string* mutable_task_id();
  inline ::std::string* release_task_id();
  
  // required uint32 user_id = 3;
  inline bool has_user_id() const;
  inline void clear_user_id();
  static const int kUserIdFieldNumber = 3;
  inline ::google::protobuf::uint32 user_id() const;
  inline void set_user_id(::google::protobuf::uint32 value);
  
  // @@protoc_insertion_point(class_scope:IM.File.IMFileState)
 private:
  inline void set_has_state();
  inline void clear_has_state();
  inline void set_has_task_id();
  inline void clear_has_task_id();
  inline void set_has_user_id();
  inline void clear_has_user_id();
  
  ::std::string* task_id_;
  int state_;
  ::google::protobuf::uint32 user_id_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];
  
  friend void  protobuf_AddDesc_IM_2eFile_2eproto();
  friend void protobuf_AssignDesc_IM_2eFile_2eproto();
  friend void protobuf_ShutdownFile_IM_2eFile_2eproto();
  
  void InitAsDefaultInstance();
  static IMFileState* default_instance_;
};
// -------------------------------------------------------------------

class IMFilePullDataReq : public ::google::protobuf::MessageLite {
 public:
  IMFilePullDataReq();
  virtual ~IMFilePullDataReq();
  
  IMFilePullDataReq(const IMFilePullDataReq& from);
  
  inline IMFilePullDataReq& operator=(const IMFilePullDataReq& from) {
    CopyFrom(from);
    return *this;
  }
  
  static const IMFilePullDataReq& default_instance();
  
  void Swap(IMFilePullDataReq* other);
  
  // implements Message ----------------------------------------------
  
  IMFilePullDataReq* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const IMFilePullDataReq& from);
  void MergeFrom(const IMFilePullDataReq& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::std::string GetTypeName() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required string task_id = 1;
  inline bool has_task_id() const;
  inline void clear_task_id();
  static const int kTaskIdFieldNumber = 1;
  inline const ::std::string& task_id() const;
  inline void set_task_id(const ::std::string& value);
  inline void set_task_id(const char* value);
  inline void set_task_id(const char* value, size_t size);
  inline ::std::string* mutable_task_id();
  inline ::std::string* release_task_id();
  
  // required uint32 user_id = 2;
  inline bool has_user_id() const;
  inline void clear_user_id();
  static const int kUserIdFieldNumber = 2;
  inline ::google::protobuf::uint32 user_id() const;
  inline void set_user_id(::google::protobuf::uint32 value);
  
  // required .IM.BaseDefine.FileType trans_mode = 3;
  inline bool has_trans_mode() const;
  inline void clear_trans_mode();
  static const int kTransModeFieldNumber = 3;
  inline IM::BaseDefine::FileType trans_mode() const;
  inline void set_trans_mode(IM::BaseDefine::FileType value);
  
  // required uint32 offset = 4;
  inline bool has_offset() const;
  inline void clear_offset();
  static const int kOffsetFieldNumber = 4;
  inline ::google::protobuf::uint32 offset() const;
  inline void set_offset(::google::protobuf::uint32 value);
  
  // required uint32 data_size = 5;
  inline bool has_data_size() const;
  inline void clear_data_size();
  static const int kDataSizeFieldNumber = 5;
  inline ::google::protobuf::uint32 data_size() const;
  inline void set_data_size(::google::protobuf::uint32 value);
  
  // @@protoc_insertion_point(class_scope:IM.File.IMFilePullDataReq)
 private:
  inline void set_has_task_id();
  inline void clear_has_task_id();
  inline void set_has_user_id();
  inline void clear_has_user_id();
  inline void set_has_trans_mode();
  inline void clear_has_trans_mode();
  inline void set_has_offset();
  inline void clear_has_offset();
  inline void set_has_data_size();
  inline void clear_has_data_size();
  
  ::std::string* task_id_;
  ::google::protobuf::uint32 user_id_;
  int trans_mode_;
  ::google::protobuf::uint32 offset_;
  ::google::protobuf::uint32 data_size_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];
  
  friend void  protobuf_AddDesc_IM_2eFile_2eproto();
  friend void protobuf_AssignDesc_IM_2eFile_2eproto();
  friend void protobuf_ShutdownFile_IM_2eFile_2eproto();
  
  void InitAsDefaultInstance();
  static IMFilePullDataReq* default_instance_;
};
// -------------------------------------------------------------------

class IMFilePullDataRsp : public ::google::protobuf::MessageLite {
 public:
  IMFilePullDataRsp();
  virtual ~IMFilePullDataRsp();
  
  IMFilePullDataRsp(const IMFilePullDataRsp& from);
  
  inline IMFilePullDataRsp& operator=(const IMFilePullDataRsp& from) {
    CopyFrom(from);
    return *this;
  }
  
  static const IMFilePullDataRsp& default_instance();
  
  void Swap(IMFilePullDataRsp* other);
  
  // implements Message ----------------------------------------------
  
  IMFilePullDataRsp* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const IMFilePullDataRsp& from);
  void MergeFrom(const IMFilePullDataRsp& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::std::string GetTypeName() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required uint32 result_code = 1;
  inline bool has_result_code() const;
  inline void clear_result_code();
  static const int kResultCodeFieldNumber = 1;
  inline ::google::protobuf::uint32 result_code() const;
  inline void set_result_code(::google::protobuf::uint32 value);
  
  // required string task_id = 2;
  inline bool has_task_id() const;
  inline void clear_task_id();
  static const int kTaskIdFieldNumber = 2;
  inline const ::std::string& task_id() const;
  inline void set_task_id(const ::std::string& value);
  inline void set_task_id(const char* value);
  inline void set_task_id(const char* value, size_t size);
  inline ::std::string* mutable_task_id();
  inline ::std::string* release_task_id();
  
  // required uint32 user_id = 3;
  inline bool has_user_id() const;
  inline void clear_user_id();
  static const int kUserIdFieldNumber = 3;
  inline ::google::protobuf::uint32 user_id() const;
  inline void set_user_id(::google::protobuf::uint32 value);
  
  // required uint32 offset = 4;
  inline bool has_offset() const;
  inline void clear_offset();
  static const int kOffsetFieldNumber = 4;
  inline ::google::protobuf::uint32 offset() const;
  inline void set_offset(::google::protobuf::uint32 value);
  
  // required bytes data = 5;
  inline bool has_data() const;
  inline void clear_data();
  static const int kDataFieldNumber = 5;
  inline const ::std::string& data() const;
  inline void set_data(const ::std::string& value);
  inline void set_data(const char* value);
  inline void set_data(const void* value, size_t size);
  inline ::std::string* mutable_data();
  inline ::std::string* release_data();
  
  // @@protoc_insertion_point(class_scope:IM.File.IMFilePullDataRsp)
 private:
  inline void set_has_result_code();
  inline void clear_has_result_code();
  inline void set_has_task_id();
  inline void clear_has_task_id();
  inline void set_has_user_id();
  inline void clear_has_user_id();
  inline void set_has_offset();
  inline void clear_has_offset();
  inline void set_has_data();
  inline void clear_has_data();
  
  ::std::string* task_id_;
  ::google::protobuf::uint32 result_code_;
  ::google::protobuf::uint32 user_id_;
  ::std::string* data_;
  ::google::protobuf::uint32 offset_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];
  
  friend void  protobuf_AddDesc_IM_2eFile_2eproto();
  friend void protobuf_AssignDesc_IM_2eFile_2eproto();
  friend void protobuf_ShutdownFile_IM_2eFile_2eproto();
  
  void InitAsDefaultInstance();
  static IMFilePullDataRsp* default_instance_;
};
// -------------------------------------------------------------------

class IMFileReq : public ::google::protobuf::MessageLite {
 public:
  IMFileReq();
  virtual ~IMFileReq();
  
  IMFileReq(const IMFileReq& from);
  
  inline IMFileReq& operator=(const IMFileReq& from) {
    CopyFrom(from);
    return *this;
  }
  
  static const IMFileReq& default_instance();
  
  void Swap(IMFileReq* other);
  
  // implements Message ----------------------------------------------
  
  IMFileReq* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const IMFileReq& from);
  void MergeFrom(const IMFileReq& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::std::string GetTypeName() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required uint32 from_user_id = 1;
  inline bool has_from_user_id() const;
  inline void clear_from_user_id();
  static const int kFromUserIdFieldNumber = 1;
  inline ::google::protobuf::uint32 from_user_id() const;
  inline void set_from_user_id(::google::protobuf::uint32 value);
  
  // required uint32 to_user_id = 2;
  inline bool has_to_user_id() const;
  inline void clear_to_user_id();
  static const int kToUserIdFieldNumber = 2;
  inline ::google::protobuf::uint32 to_user_id() const;
  inline void set_to_user_id(::google::protobuf::uint32 value);
  
  // required string file_name = 3;
  inline bool has_file_name() const;
  inline void clear_file_name();
  static const int kFileNameFieldNumber = 3;
  inline const ::std::string& file_name() const;
  inline void set_file_name(const ::std::string& value);
  inline void set_file_name(const char* value);
  inline void set_file_name(const char* value, size_t size);
  inline ::std::string* mutable_file_name();
  inline ::std::string* release_file_name();
  
  // required uint32 file_size = 4;
  inline bool has_file_size() const;
  inline void clear_file_size();
  static const int kFileSizeFieldNumber = 4;
  inline ::google::protobuf::uint32 file_size() const;
  inline void set_file_size(::google::protobuf::uint32 value);
  
  // required .IM.BaseDefine.FileType trans_mode = 5;
  inline bool has_trans_mode() const;
  inline void clear_trans_mode();
  static const int kTransModeFieldNumber = 5;
  inline IM::BaseDefine::FileType trans_mode() const;
  inline void set_trans_mode(IM::BaseDefine::FileType value);
  
  // @@protoc_insertion_point(class_scope:IM.File.IMFileReq)
 private:
  inline void set_has_from_user_id();
  inline void clear_has_from_user_id();
  inline void set_has_to_user_id();
  inline void clear_has_to_user_id();
  inline void set_has_file_name();
  inline void clear_has_file_name();
  inline void set_has_file_size();
  inline void clear_has_file_size();
  inline void set_has_trans_mode();
  inline void clear_has_trans_mode();
  
  ::google::protobuf::uint32 from_user_id_;
  ::google::protobuf::uint32 to_user_id_;
  ::std::string* file_name_;
  ::google::protobuf::uint32 file_size_;
  int trans_mode_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];
  
  friend void  protobuf_AddDesc_IM_2eFile_2eproto();
  friend void protobuf_AssignDesc_IM_2eFile_2eproto();
  friend void protobuf_ShutdownFile_IM_2eFile_2eproto();
  
  void InitAsDefaultInstance();
  static IMFileReq* default_instance_;
};
// -------------------------------------------------------------------

class IMFileRsp : public ::google::protobuf::MessageLite {
 public:
  IMFileRsp();
  virtual ~IMFileRsp();
  
  IMFileRsp(const IMFileRsp& from);
  
  inline IMFileRsp& operator=(const IMFileRsp& from) {
    CopyFrom(from);
    return *this;
  }
  
  static const IMFileRsp& default_instance();
  
  void Swap(IMFileRsp* other);
  
  // implements Message ----------------------------------------------
  
  IMFileRsp* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const IMFileRsp& from);
  void MergeFrom(const IMFileRsp& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::std::string GetTypeName() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required uint32 result_code = 1;
  inline bool has_result_code() const;
  inline void clear_result_code();
  static const int kResultCodeFieldNumber = 1;
  inline ::google::protobuf::uint32 result_code() const;
  inline void set_result_code(::google::protobuf::uint32 value);
  
  // required uint32 from_user_id = 2;
  inline bool has_from_user_id() const;
  inline void clear_from_user_id();
  static const int kFromUserIdFieldNumber = 2;
  inline ::google::protobuf::uint32 from_user_id() const;
  inline void set_from_user_id(::google::protobuf::uint32 value);
  
  // required uint32 to_user_id = 3;
  inline bool has_to_user_id() const;
  inline void clear_to_user_id();
  static const int kToUserIdFieldNumber = 3;
  inline ::google::protobuf::uint32 to_user_id() const;
  inline void set_to_user_id(::google::protobuf::uint32 value);
  
  // required string file_name = 4;
  inline bool has_file_name() const;
  inline void clear_file_name();
  static const int kFileNameFieldNumber = 4;
  inline const ::std::string& file_name() const;
  inline void set_file_name(const ::std::string& value);
  inline void set_file_name(const char* value);
  inline void set_file_name(const char* value, size_t size);
  inline ::std::string* mutable_file_name();
  inline ::std::string* release_file_name();
  
  // required string task_id = 5;
  inline bool has_task_id() const;
  inline void clear_task_id();
  static const int kTaskIdFieldNumber = 5;
  inline const ::std::string& task_id() const;
  inline void set_task_id(const ::std::string& value);
  inline void set_task_id(const char* value);
  inline void set_task_id(const char* value, size_t size);
  inline ::std::string* mutable_task_id();
  inline ::std::string* release_task_id();
  
  // repeated .IM.BaseDefine.IpAddr ip_addr_list = 6;
  inline int ip_addr_list_size() const;
  inline void clear_ip_addr_list();
  static const int kIpAddrListFieldNumber = 6;
  inline const ::IM::BaseDefine::IpAddr& ip_addr_list(int index) const;
  inline ::IM::BaseDefine::IpAddr* mutable_ip_addr_list(int index);
  inline ::IM::BaseDefine::IpAddr* add_ip_addr_list();
  inline const ::google::protobuf::RepeatedPtrField< ::IM::BaseDefine::IpAddr >&
      ip_addr_list() const;
  inline ::google::protobuf::RepeatedPtrField< ::IM::BaseDefine::IpAddr >*
      mutable_ip_addr_list();
  
  // required .IM.BaseDefine.FileType trans_mode = 7;
  inline bool has_trans_mode() const;
  inline void clear_trans_mode();
  static const int kTransModeFieldNumber = 7;
  inline IM::BaseDefine::FileType trans_mode() const;
  inline void set_trans_mode(IM::BaseDefine::FileType value);
  
  // @@protoc_insertion_point(class_scope:IM.File.IMFileRsp)
 private:
  inline void set_has_result_code();
  inline void clear_has_result_code();
  inline void set_has_from_user_id();
  inline void clear_has_from_user_id();
  inline void set_has_to_user_id();
  inline void clear_has_to_user_id();
  inline void set_has_file_name();
  inline void clear_has_file_name();
  inline void set_has_task_id();
  inline void clear_has_task_id();
  inline void set_has_trans_mode();
  inline void clear_has_trans_mode();
  
  ::google::protobuf::uint32 result_code_;
  ::google::protobuf::uint32 from_user_id_;
  ::std::string* file_name_;
  ::std::string* task_id_;
  ::google::protobuf::uint32 to_user_id_;
  int trans_mode_;
  ::google::protobuf::RepeatedPtrField< ::IM::BaseDefine::IpAddr > ip_addr_list_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(7 + 31) / 32];
  
  friend void  protobuf_AddDesc_IM_2eFile_2eproto();
  friend void protobuf_AssignDesc_IM_2eFile_2eproto();
  friend void protobuf_ShutdownFile_IM_2eFile_2eproto();
  
  void InitAsDefaultInstance();
  static IMFileRsp* default_instance_;
};
// -------------------------------------------------------------------

class IMFileNotify : public ::google::protobuf::MessageLite {
 public:
  IMFileNotify();
  virtual ~IMFileNotify();
  
  IMFileNotify(const IMFileNotify& from);
  
  inline IMFileNotify& operator=(const IMFileNotify& from) {
    CopyFrom(from);
    return *this;
  }
  
  static const IMFileNotify& default_instance();
  
  void Swap(IMFileNotify* other);
  
  // implements Message ----------------------------------------------
  
  IMFileNotify* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const IMFileNotify& from);
  void MergeFrom(const IMFileNotify& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::std::string GetTypeName() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required uint32 from_user_id = 1;
  inline bool has_from_user_id() const;
  inline void clear_from_user_id();
  static const int kFromUserIdFieldNumber = 1;
  inline ::google::protobuf::uint32 from_user_id() const;
  inline void set_from_user_id(::google::protobuf::uint32 value);
  
  // required uint32 to_user_id = 2;
  inline bool has_to_user_id() const;
  inline void clear_to_user_id();
  static const int kToUserIdFieldNumber = 2;
  inline ::google::protobuf::uint32 to_user_id() const;
  inline void set_to_user_id(::google::protobuf::uint32 value);
  
  // required string file_name = 3;
  inline bool has_file_name() const;
  inline void clear_file_name();
  static const int kFileNameFieldNumber = 3;
  inline const ::std::string& file_name() const;
  inline void set_file_name(const ::std::string& value);
  inline void set_file_name(const char* value);
  inline void set_file_name(const char* value, size_t size);
  inline ::std::string* mutable_file_name();
  inline ::std::string* release_file_name();
  
  // required uint32 file_size = 4;
  inline bool has_file_size() const;
  inline void clear_file_size();
  static const int kFileSizeFieldNumber = 4;
  inline ::google::protobuf::uint32 file_size() const;
  inline void set_file_size(::google::protobuf::uint32 value);
  
  // required string task_id = 5;
  inline bool has_task_id() const;
  inline void clear_task_id();
  static const int kTaskIdFieldNumber = 5;
  inline const ::std::string& task_id() const;
  inline void set_task_id(const ::std::string& value);
  inline void set_task_id(const char* value);
  inline void set_task_id(const char* value, size_t size);
  inline ::std::string* mutable_task_id();
  inline ::std::string* release_task_id();
  
  // repeated .IM.BaseDefine.IpAddr ip_addr_list = 6;
  inline int ip_addr_list_size() const;
  inline void clear_ip_addr_list();
  static const int kIpAddrListFieldNumber = 6;
  inline const ::IM::BaseDefine::IpAddr& ip_addr_list(int index) const;
  inline ::IM::BaseDefine::IpAddr* mutable_ip_addr_list(int index);
  inline ::IM::BaseDefine::IpAddr* add_ip_addr_list();
  inline const ::google::protobuf::RepeatedPtrField< ::IM::BaseDefine::IpAddr >&
      ip_addr_list() const;
  inline ::google::protobuf::RepeatedPtrField< ::IM::BaseDefine::IpAddr >*
      mutable_ip_addr_list();
  
  // required .IM.BaseDefine.FileType trans_mode = 7;
  inline bool has_trans_mode() const;
  inline void clear_trans_mode();
  static const int kTransModeFieldNumber = 7;
  inline IM::BaseDefine::FileType trans_mode() const;
  inline void set_trans_mode(IM::BaseDefine::FileType value);
  
  // required uint32 offline_ready = 8;
  inline bool has_offline_ready() const;
  inline void clear_offline_ready();
  static const int kOfflineReadyFieldNumber = 8;
  inline ::google::protobuf::uint32 offline_ready() const;
  inline void set_offline_ready(::google::protobuf::uint32 value);
  
  // @@protoc_insertion_point(class_scope:IM.File.IMFileNotify)
 private:
  inline void set_has_from_user_id();
  inline void clear_has_from_user_id();
  inline void set_has_to_user_id();
  inline void clear_has_to_user_id();
  inline void set_has_file_name();
  inline void clear_has_file_name();
  inline void set_has_file_size();
  inline void clear_has_file_size();
  inline void set_has_task_id();
  inline void clear_has_task_id();
  inline void set_has_trans_mode();
  inline void clear_has_trans_mode();
  inline void set_has_offline_ready();
  inline void clear_has_offline_ready();
  
  ::google::protobuf::uint32 from_user_id_;
  ::google::protobuf::uint32 to_user_id_;
  ::std::string* file_name_;
  ::std::string* task_id_;
  ::google::protobuf::uint32 file_size_;
  int trans_mode_;
  ::google::protobuf::RepeatedPtrField< ::IM::BaseDefine::IpAddr > ip_addr_list_;
  ::google::protobuf::uint32 offline_ready_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(8 + 31) / 32];
  
  friend void  protobuf_AddDesc_IM_2eFile_2eproto();
  friend void protobuf_AssignDesc_IM_2eFile_2eproto();
  friend void protobuf_ShutdownFile_IM_2eFile_2eproto();
  
  void InitAsDefaultInstance();
  static IMFileNotify* default_instance_;
};
// -------------------------------------------------------------------

class IMFileHasOfflineReq : public ::google::protobuf::MessageLite {
 public:
  IMFileHasOfflineReq();
  virtual ~IMFileHasOfflineReq();
  
  IMFileHasOfflineReq(const IMFileHasOfflineReq& from);
  
  inline IMFileHasOfflineReq& operator=(const IMFileHasOfflineReq& from) {
    CopyFrom(from);
    return *this;
  }
  
  static const IMFileHasOfflineReq& default_instance();
  
  void Swap(IMFileHasOfflineReq* other);
  
  // implements Message ----------------------------------------------
  
  IMFileHasOfflineReq* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const IMFileHasOfflineReq& from);
  void MergeFrom(const IMFileHasOfflineReq& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::std::string GetTypeName() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required uint32 user_id = 1;
  inline bool has_user_id() const;
  inline void clear_user_id();
  static const int kUserIdFieldNumber = 1;
  inline ::google::protobuf::uint32 user_id() const;
  inline void set_user_id(::google::protobuf::uint32 value);
  
  // optional bytes attach_data = 20;
  inline bool has_attach_data() const;
  inline void clear_attach_data();
  static const int kAttachDataFieldNumber = 20;
  inline const ::std::string& attach_data() const;
  inline void set_attach_data(const ::std::string& value);
  inline void set_attach_data(const char* value);
  inline void set_attach_data(const void* value, size_t size);
  inline ::std::string* mutable_attach_data();
  inline ::std::string* release_attach_data();
  
  // @@protoc_insertion_point(class_scope:IM.File.IMFileHasOfflineReq)
 private:
  inline void set_has_user_id();
  inline void clear_has_user_id();
  inline void set_has_attach_data();
  inline void clear_has_attach_data();
  
  ::std::string* attach_data_;
  ::google::protobuf::uint32 user_id_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];
  
  friend void  protobuf_AddDesc_IM_2eFile_2eproto();
  friend void protobuf_AssignDesc_IM_2eFile_2eproto();
  friend void protobuf_ShutdownFile_IM_2eFile_2eproto();
  
  void InitAsDefaultInstance();
  static IMFileHasOfflineReq* default_instance_;
};
// -------------------------------------------------------------------

class IMFileHasOfflineRsp : public ::google::protobuf::MessageLite {
 public:
  IMFileHasOfflineRsp();
  virtual ~IMFileHasOfflineRsp();
  
  IMFileHasOfflineRsp(const IMFileHasOfflineRsp& from);
  
  inline IMFileHasOfflineRsp& operator=(const IMFileHasOfflineRsp& from) {
    CopyFrom(from);
    return *this;
  }
  
  static const IMFileHasOfflineRsp& default_instance();
  
  void Swap(IMFileHasOfflineRsp* other);
  
  // implements Message ----------------------------------------------
  
  IMFileHasOfflineRsp* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const IMFileHasOfflineRsp& from);
  void MergeFrom(const IMFileHasOfflineRsp& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::std::string GetTypeName() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required uint32 user_id = 1;
  inline bool has_user_id() const;
  inline void clear_user_id();
  static const int kUserIdFieldNumber = 1;
  inline ::google::protobuf::uint32 user_id() const;
  inline void set_user_id(::google::protobuf::uint32 value);
  
  // repeated .IM.BaseDefine.OfflineFileInfo offline_file_list = 2;
  inline int offline_file_list_size() const;
  inline void clear_offline_file_list();
  static const int kOfflineFileListFieldNumber = 2;
  inline const ::IM::BaseDefine::OfflineFileInfo& offline_file_list(int index) const;
  inline ::IM::BaseDefine::OfflineFileInfo* mutable_offline_file_list(int index);
  inline ::IM::BaseDefine::OfflineFileInfo* add_offline_file_list();
  inline const ::google::protobuf::RepeatedPtrField< ::IM::BaseDefine::OfflineFileInfo >&
      offline_file_list() const;
  inline ::google::protobuf::RepeatedPtrField< ::IM::BaseDefine::OfflineFileInfo >*
      mutable_offline_file_list();
  
  // repeated .IM.BaseDefine.IpAddr ip_addr_list = 3;
  inline int ip_addr_list_size() const;
  inline void clear_ip_addr_list();
  static const int kIpAddrListFieldNumber = 3;
  inline const ::IM::BaseDefine::IpAddr& ip_addr_list(int index) const;
  inline ::IM::BaseDefine::IpAddr* mutable_ip_addr_list(int index);
  inline ::IM::BaseDefine::IpAddr* add_ip_addr_list();
  inline const ::google::protobuf::RepeatedPtrField< ::IM::BaseDefine::IpAddr >&
      ip_addr_list() const;
  inline ::google::protobuf::RepeatedPtrField< ::IM::BaseDefine::IpAddr >*
      mutable_ip_addr_list();
  
  // optional bytes attach_data = 20;
  inline bool has_attach_data() const;
  inline void clear_attach_data();
  static const int kAttachDataFieldNumber = 20;
  inline const ::std::string& attach_data() const;
  inline void set_attach_data(const ::std::string& value);
  inline void set_attach_data(const char* value);
  inline void set_attach_data(const void* value, size_t size);
  inline ::std::string* mutable_attach_data();
  inline ::std::string* release_attach_data();
  
  // @@protoc_insertion_point(class_scope:IM.File.IMFileHasOfflineRsp)
 private:
  inline void set_has_user_id();
  inline void clear_has_user_id();
  inline void set_has_attach_data();
  inline void clear_has_attach_data();
  
  ::google::protobuf::RepeatedPtrField< ::IM::BaseDefine::OfflineFileInfo > offline_file_list_;
  ::google::protobuf::RepeatedPtrField< ::IM::BaseDefine::IpAddr > ip_addr_list_;
  ::std::string* attach_data_;
  ::google::protobuf::uint32 user_id_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];
  
  friend void  protobuf_AddDesc_IM_2eFile_2eproto();
  friend void protobuf_AssignDesc_IM_2eFile_2eproto();
  friend void protobuf_ShutdownFile_IM_2eFile_2eproto();
  
  void InitAsDefaultInstance();
  static IMFileHasOfflineRsp* default_instance_;
};
// -------------------------------------------------------------------

class IMFileAddOfflineReq : public ::google::protobuf::MessageLite {
 public:
  IMFileAddOfflineReq();
  virtual ~IMFileAddOfflineReq();
  
  IMFileAddOfflineReq(const IMFileAddOfflineReq& from);
  
  inline IMFileAddOfflineReq& operator=(const IMFileAddOfflineReq& from) {
    CopyFrom(from);
    return *this;
  }
  
  static const IMFileAddOfflineReq& default_instance();
  
  void Swap(IMFileAddOfflineReq* other);
  
  // implements Message ----------------------------------------------
  
  IMFileAddOfflineReq* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const IMFileAddOfflineReq& from);
  void MergeFrom(const IMFileAddOfflineReq& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::std::string GetTypeName() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required uint32 from_user_id = 1;
  inline bool has_from_user_id() const;
  inline void clear_from_user_id();
  static const int kFromUserIdFieldNumber = 1;
  inline ::google::protobuf::uint32 from_user_id() const;
  inline void set_from_user_id(::google::protobuf::uint32 value);
  
  // required uint32 to_user_id = 2;
  inline bool has_to_user_id() const;
  inline void clear_to_user_id();
  static const int kToUserIdFieldNumber = 2;
  inline ::google::protobuf::uint32 to_user_id() const;
  inline void set_to_user_id(::google::protobuf::uint32 value);
  
  // required string task_id = 3;
  inline bool has_task_id() const;
  inline void clear_task_id();
  static const int kTaskIdFieldNumber = 3;
  inline const ::std::string& task_id() const;
  inline void set_task_id(const ::std::string& value);
  inline void set_task_id(const char* value);
  inline void set_task_id(const char* value, size_t size);
  inline ::std::string* mutable_task_id();
  inline ::std::string* release_task_id();
  
  // required string file_name = 4;
  inline bool has_file_name() const;
  inline void clear_file_name();
  static const int kFileNameFieldNumber = 4;
  inline const ::std::string& file_name() const;
  inline void set_file_name(const ::std::string& value);
  inline void set_file_name(const char* value);
  inline void set_file_name(const char* value, size_t size);
  inline ::std::string* mutable_file_name();
  inline ::std::string* release_file_name();
  
  // required uint32 file_size = 5;
  inline bool has_file_size() const;
  inline void clear_file_size();
  static const int kFileSizeFieldNumber = 5;
  inline ::google::protobuf::uint32 file_size() const;
  inline void set_file_size(::google::protobuf::uint32 value);
  
  // @@protoc_insertion_point(class_scope:IM.File.IMFileAddOfflineReq)
 private:
  inline void set_has_from_user_id();
  inline void clear_has_from_user_id();
  inline void set_has_to_user_id();
  inline void clear_has_to_user_id();
  inline void set_has_task_id();
  inline void clear_has_task_id();
  inline void set_has_file_name();
  inline void clear_has_file_name();
  inline void set_has_file_size();
  inline void clear_has_file_size();
  
  ::google::protobuf::uint32 from_user_id_;
  ::google::protobuf::uint32 to_user_id_;
  ::std::string* task_id_;
  ::std::string* file_name_;
  ::google::protobuf::uint32 file_size_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];
  
  friend void  protobuf_AddDesc_IM_2eFile_2eproto();
  friend void protobuf_AssignDesc_IM_2eFile_2eproto();
  friend void protobuf_ShutdownFile_IM_2eFile_2eproto();
  
  void InitAsDefaultInstance();
  static IMFileAddOfflineReq* default_instance_;
};
// -------------------------------------------------------------------

class IMFileDelOfflineReq : public ::google::protobuf::MessageLite {
 public:
  IMFileDelOfflineReq();
  virtual ~IMFileDelOfflineReq();
  
  IMFileDelOfflineReq(const IMFileDelOfflineReq& from);
  
  inline IMFileDelOfflineReq& operator=(const IMFileDelOfflineReq& from) {
    CopyFrom(from);
    return *this;
  }
  
  static const IMFileDelOfflineReq& default_instance();
  
  void Swap(IMFileDelOfflineReq* other);
  
  // implements Message ----------------------------------------------
  
  IMFileDelOfflineReq* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const IMFileDelOfflineReq& from);
  void MergeFrom(const IMFileDelOfflineReq& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::std::string GetTypeName() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required uint32 from_user_id = 1;
  inline bool has_from_user_id() const;
  inline void clear_from_user_id();
  static const int kFromUserIdFieldNumber = 1;
  inline ::google::protobuf::uint32 from_user_id() const;
  inline void set_from_user_id(::google::protobuf::uint32 value);
  
  // required uint32 to_user_id = 2;
  inline bool has_to_user_id() const;
  inline void clear_to_user_id();
  static const int kToUserIdFieldNumber = 2;
  inline ::google::protobuf::uint32 to_user_id() const;
  inline void set_to_user_id(::google::protobuf::uint32 value);
  
  // required string task_id = 3;
  inline bool has_task_id() const;
  inline void clear_task_id();
  static const int kTaskIdFieldNumber = 3;
  inline const ::std::string& task_id() const;
  inline void set_task_id(const ::std::string& value);
  inline void set_task_id(const char* value);
  inline void set_task_id(const char* value, size_t size);
  inline ::std::string* mutable_task_id();
  inline ::std::string* release_task_id();
  
  // @@protoc_insertion_point(class_scope:IM.File.IMFileDelOfflineReq)
 private:
  inline void set_has_from_user_id();
  inline void clear_has_from_user_id();
  inline void set_has_to_user_id();
  inline void clear_has_to_user_id();
  inline void set_has_task_id();
  inline void clear_has_task_id();
  
  ::google::protobuf::uint32 from_user_id_;
  ::google::protobuf::uint32 to_user_id_;
  ::std::string* task_id_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];
  
  friend void  protobuf_AddDesc_IM_2eFile_2eproto();
  friend void protobuf_AssignDesc_IM_2eFile_2eproto();
  friend void protobuf_ShutdownFile_IM_2eFile_2eproto();
  
  void InitAsDefaultInstance();
  static IMFileDelOfflineReq* default_instance_;
};
// ===================================================================


// ===================================================================

// IMFileLoginReq

// required uint32 user_id = 1;
inline bool IMFileLoginReq::has_user_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void IMFileLoginReq::set_has_user_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void IMFileLoginReq::clear_has_user_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void IMFileLoginReq::clear_user_id() {
  user_id_ = 0u;
  clear_has_user_id();
}
inline ::google::protobuf::uint32 IMFileLoginReq::user_id() const {
  return user_id_;
}
inline void IMFileLoginReq::set_user_id(::google::protobuf::uint32 value) {
  set_has_user_id();
  user_id_ = value;
}

// required string task_id = 2;
inline bool IMFileLoginReq::has_task_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void IMFileLoginReq::set_has_task_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void IMFileLoginReq::clear_has_task_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void IMFileLoginReq::clear_task_id() {
  if (task_id_ != &::google::protobuf::internal::kEmptyString) {
    task_id_->clear();
  }
  clear_has_task_id();
}
inline const ::std::string& IMFileLoginReq::task_id() const {
  return *task_id_;
}
inline void IMFileLoginReq::set_task_id(const ::std::string& value) {
  set_has_task_id();
  if (task_id_ == &::google::protobuf::internal::kEmptyString) {
    task_id_ = new ::std::string;
  }
  task_id_->assign(value);
}
inline void IMFileLoginReq::set_task_id(const char* value) {
  set_has_task_id();
  if (task_id_ == &::google::protobuf::internal::kEmptyString) {
    task_id_ = new ::std::string;
  }
  task_id_->assign(value);
}
inline void IMFileLoginReq::set_task_id(const char* value, size_t size) {
  set_has_task_id();
  if (task_id_ == &::google::protobuf::internal::kEmptyString) {
    task_id_ = new ::std::string;
  }
  task_id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* IMFileLoginReq::mutable_task_id() {
  set_has_task_id();
  if (task_id_ == &::google::protobuf::internal::kEmptyString) {
    task_id_ = new ::std::string;
  }
  return task_id_;
}
inline ::std::string* IMFileLoginReq::release_task_id() {
  clear_has_task_id();
  if (task_id_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = task_id_;
    task_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// required .IM.BaseDefine.ClientFileRole file_role = 3;
inline bool IMFileLoginReq::has_file_role() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void IMFileLoginReq::set_has_file_role() {
  _has_bits_[0] |= 0x00000004u;
}
inline void IMFileLoginReq::clear_has_file_role() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void IMFileLoginReq::clear_file_role() {
  file_role_ = 1;
  clear_has_file_role();
}
inline IM::BaseDefine::ClientFileRole IMFileLoginReq::file_role() const {
  return static_cast< IM::BaseDefine::ClientFileRole >(file_role_);
}
inline void IMFileLoginReq::set_file_role(IM::BaseDefine::ClientFileRole value) {
  GOOGLE_DCHECK(IM::BaseDefine::ClientFileRole_IsValid(value));
  set_has_file_role();
  file_role_ = value;
}

// -------------------------------------------------------------------

// IMFileLoginRsp

// required uint32 result_code = 1;
inline bool IMFileLoginRsp::has_result_code() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void IMFileLoginRsp::set_has_result_code() {
  _has_bits_[0] |= 0x00000001u;
}
inline void IMFileLoginRsp::clear_has_result_code() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void IMFileLoginRsp::clear_result_code() {
  result_code_ = 0u;
  clear_has_result_code();
}
inline ::google::protobuf::uint32 IMFileLoginRsp::result_code() const {
  return result_code_;
}
inline void IMFileLoginRsp::set_result_code(::google::protobuf::uint32 value) {
  set_has_result_code();
  result_code_ = value;
}

// required string task_id = 2;
inline bool IMFileLoginRsp::has_task_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void IMFileLoginRsp::set_has_task_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void IMFileLoginRsp::clear_has_task_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void IMFileLoginRsp::clear_task_id() {
  if (task_id_ != &::google::protobuf::internal::kEmptyString) {
    task_id_->clear();
  }
  clear_has_task_id();
}
inline const ::std::string& IMFileLoginRsp::task_id() const {
  return *task_id_;
}
inline void IMFileLoginRsp::set_task_id(const ::std::string& value) {
  set_has_task_id();
  if (task_id_ == &::google::protobuf::internal::kEmptyString) {
    task_id_ = new ::std::string;
  }
  task_id_->assign(value);
}
inline void IMFileLoginRsp::set_task_id(const char* value) {
  set_has_task_id();
  if (task_id_ == &::google::protobuf::internal::kEmptyString) {
    task_id_ = new ::std::string;
  }
  task_id_->assign(value);
}
inline void IMFileLoginRsp::set_task_id(const char* value, size_t size) {
  set_has_task_id();
  if (task_id_ == &::google::protobuf::internal::kEmptyString) {
    task_id_ = new ::std::string;
  }
  task_id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* IMFileLoginRsp::mutable_task_id() {
  set_has_task_id();
  if (task_id_ == &::google::protobuf::internal::kEmptyString) {
    task_id_ = new ::std::string;
  }
  return task_id_;
}
inline ::std::string* IMFileLoginRsp::release_task_id() {
  clear_has_task_id();
  if (task_id_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = task_id_;
    task_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// -------------------------------------------------------------------

// IMFileState

// required .IM.BaseDefine.ClientFileState state = 1;
inline bool IMFileState::has_state() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void IMFileState::set_has_state() {
  _has_bits_[0] |= 0x00000001u;
}
inline void IMFileState::clear_has_state() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void IMFileState::clear_state() {
  state_ = 0;
  clear_has_state();
}
inline IM::BaseDefine::ClientFileState IMFileState::state() const {
  return static_cast< IM::BaseDefine::ClientFileState >(state_);
}
inline void IMFileState::set_state(IM::BaseDefine::ClientFileState value) {
  GOOGLE_DCHECK(IM::BaseDefine::ClientFileState_IsValid(value));
  set_has_state();
  state_ = value;
}

// required string task_id = 2;
inline bool IMFileState::has_task_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void IMFileState::set_has_task_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void IMFileState::clear_has_task_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void IMFileState::clear_task_id() {
  if (task_id_ != &::google::protobuf::internal::kEmptyString) {
    task_id_->clear();
  }
  clear_has_task_id();
}
inline const ::std::string& IMFileState::task_id() const {
  return *task_id_;
}
inline void IMFileState::set_task_id(const ::std::string& value) {
  set_has_task_id();
  if (task_id_ == &::google::protobuf::internal::kEmptyString) {
    task_id_ = new ::std::string;
  }
  task_id_->assign(value);
}
inline void IMFileState::set_task_id(const char* value) {
  set_has_task_id();
  if (task_id_ == &::google::protobuf::internal::kEmptyString) {
    task_id_ = new ::std::string;
  }
  task_id_->assign(value);
}
inline void IMFileState::set_task_id(const char* value, size_t size) {
  set_has_task_id();
  if (task_id_ == &::google::protobuf::internal::kEmptyString) {
    task_id_ = new ::std::string;
  }
  task_id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* IMFileState::mutable_task_id() {
  set_has_task_id();
  if (task_id_ == &::google::protobuf::internal::kEmptyString) {
    task_id_ = new ::std::string;
  }
  return task_id_;
}
inline ::std::string* IMFileState::release_task_id() {
  clear_has_task_id();
  if (task_id_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = task_id_;
    task_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// required uint32 user_id = 3;
inline bool IMFileState::has_user_id() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void IMFileState::set_has_user_id() {
  _has_bits_[0] |= 0x00000004u;
}
inline void IMFileState::clear_has_user_id() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void IMFileState::clear_user_id() {
  user_id_ = 0u;
  clear_has_user_id();
}
inline ::google::protobuf::uint32 IMFileState::user_id() const {
  return user_id_;
}
inline void IMFileState::set_user_id(::google::protobuf::uint32 value) {
  set_has_user_id();
  user_id_ = value;
}

// -------------------------------------------------------------------

// IMFilePullDataReq

// required string task_id = 1;
inline bool IMFilePullDataReq::has_task_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void IMFilePullDataReq::set_has_task_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void IMFilePullDataReq::clear_has_task_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void IMFilePullDataReq::clear_task_id() {
  if (task_id_ != &::google::protobuf::internal::kEmptyString) {
    task_id_->clear();
  }
  clear_has_task_id();
}
inline const ::std::string& IMFilePullDataReq::task_id() const {
  return *task_id_;
}
inline void IMFilePullDataReq::set_task_id(const ::std::string& value) {
  set_has_task_id();
  if (task_id_ == &::google::protobuf::internal::kEmptyString) {
    task_id_ = new ::std::string;
  }
  task_id_->assign(value);
}
inline void IMFilePullDataReq::set_task_id(const char* value) {
  set_has_task_id();
  if (task_id_ == &::google::protobuf::internal::kEmptyString) {
    task_id_ = new ::std::string;
  }
  task_id_->assign(value);
}
inline void IMFilePullDataReq::set_task_id(const char* value, size_t size) {
  set_has_task_id();
  if (task_id_ == &::google::protobuf::internal::kEmptyString) {
    task_id_ = new ::std::string;
  }
  task_id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* IMFilePullDataReq::mutable_task_id() {
  set_has_task_id();
  if (task_id_ == &::google::protobuf::internal::kEmptyString) {
    task_id_ = new ::std::string;
  }
  return task_id_;
}
inline ::std::string* IMFilePullDataReq::release_task_id() {
  clear_has_task_id();
  if (task_id_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = task_id_;
    task_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// required uint32 user_id = 2;
inline bool IMFilePullDataReq::has_user_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void IMFilePullDataReq::set_has_user_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void IMFilePullDataReq::clear_has_user_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void IMFilePullDataReq::clear_user_id() {
  user_id_ = 0u;
  clear_has_user_id();
}
inline ::google::protobuf::uint32 IMFilePullDataReq::user_id() const {
  return user_id_;
}
inline void IMFilePullDataReq::set_user_id(::google::protobuf::uint32 value) {
  set_has_user_id();
  user_id_ = value;
}

// required .IM.BaseDefine.FileType trans_mode = 3;
inline bool IMFilePullDataReq::has_trans_mode() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void IMFilePullDataReq::set_has_trans_mode() {
  _has_bits_[0] |= 0x00000004u;
}
inline void IMFilePullDataReq::clear_has_trans_mode() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void IMFilePullDataReq::clear_trans_mode() {
  trans_mode_ = 1;
  clear_has_trans_mode();
}
inline IM::BaseDefine::FileType IMFilePullDataReq::trans_mode() const {
  return static_cast< IM::BaseDefine::FileType >(trans_mode_);
}
inline void IMFilePullDataReq::set_trans_mode(IM::BaseDefine::FileType value) {
  GOOGLE_DCHECK(IM::BaseDefine::FileType_IsValid(value));
  set_has_trans_mode();
  trans_mode_ = value;
}

// required uint32 offset = 4;
inline bool IMFilePullDataReq::has_offset() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void IMFilePullDataReq::set_has_offset() {
  _has_bits_[0] |= 0x00000008u;
}
inline void IMFilePullDataReq::clear_has_offset() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void IMFilePullDataReq::clear_offset() {
  offset_ = 0u;
  clear_has_offset();
}
inline ::google::protobuf::uint32 IMFilePullDataReq::offset() const {
  return offset_;
}
inline void IMFilePullDataReq::set_offset(::google::protobuf::uint32 value) {
  set_has_offset();
  offset_ = value;
}

// required uint32 data_size = 5;
inline bool IMFilePullDataReq::has_data_size() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void IMFilePullDataReq::set_has_data_size() {
  _has_bits_[0] |= 0x00000010u;
}
inline void IMFilePullDataReq::clear_has_data_size() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void IMFilePullDataReq::clear_data_size() {
  data_size_ = 0u;
  clear_has_data_size();
}
inline ::google::protobuf::uint32 IMFilePullDataReq::data_size() const {
  return data_size_;
}
inline void IMFilePullDataReq::set_data_size(::google::protobuf::uint32 value) {
  set_has_data_size();
  data_size_ = value;
}

// -------------------------------------------------------------------

// IMFilePullDataRsp

// required uint32 result_code = 1;
inline bool IMFilePullDataRsp::has_result_code() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void IMFilePullDataRsp::set_has_result_code() {
  _has_bits_[0] |= 0x00000001u;
}
inline void IMFilePullDataRsp::clear_has_result_code() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void IMFilePullDataRsp::clear_result_code() {
  result_code_ = 0u;
  clear_has_result_code();
}
inline ::google::protobuf::uint32 IMFilePullDataRsp::result_code() const {
  return result_code_;
}
inline void IMFilePullDataRsp::set_result_code(::google::protobuf::uint32 value) {
  set_has_result_code();
  result_code_ = value;
}

// required string task_id = 2;
inline bool IMFilePullDataRsp::has_task_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void IMFilePullDataRsp::set_has_task_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void IMFilePullDataRsp::clear_has_task_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void IMFilePullDataRsp::clear_task_id() {
  if (task_id_ != &::google::protobuf::internal::kEmptyString) {
    task_id_->clear();
  }
  clear_has_task_id();
}
inline const ::std::string& IMFilePullDataRsp::task_id() const {
  return *task_id_;
}
inline void IMFilePullDataRsp::set_task_id(const ::std::string& value) {
  set_has_task_id();
  if (task_id_ == &::google::protobuf::internal::kEmptyString) {
    task_id_ = new ::std::string;
  }
  task_id_->assign(value);
}
inline void IMFilePullDataRsp::set_task_id(const char* value) {
  set_has_task_id();
  if (task_id_ == &::google::protobuf::internal::kEmptyString) {
    task_id_ = new ::std::string;
  }
  task_id_->assign(value);
}
inline void IMFilePullDataRsp::set_task_id(const char* value, size_t size) {
  set_has_task_id();
  if (task_id_ == &::google::protobuf::internal::kEmptyString) {
    task_id_ = new ::std::string;
  }
  task_id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* IMFilePullDataRsp::mutable_task_id() {
  set_has_task_id();
  if (task_id_ == &::google::protobuf::internal::kEmptyString) {
    task_id_ = new ::std::string;
  }
  return task_id_;
}
inline ::std::string* IMFilePullDataRsp::release_task_id() {
  clear_has_task_id();
  if (task_id_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = task_id_;
    task_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// required uint32 user_id = 3;
inline bool IMFilePullDataRsp::has_user_id() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void IMFilePullDataRsp::set_has_user_id() {
  _has_bits_[0] |= 0x00000004u;
}
inline void IMFilePullDataRsp::clear_has_user_id() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void IMFilePullDataRsp::clear_user_id() {
  user_id_ = 0u;
  clear_has_user_id();
}
inline ::google::protobuf::uint32 IMFilePullDataRsp::user_id() const {
  return user_id_;
}
inline void IMFilePullDataRsp::set_user_id(::google::protobuf::uint32 value) {
  set_has_user_id();
  user_id_ = value;
}

// required uint32 offset = 4;
inline bool IMFilePullDataRsp::has_offset() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void IMFilePullDataRsp::set_has_offset() {
  _has_bits_[0] |= 0x00000008u;
}
inline void IMFilePullDataRsp::clear_has_offset() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void IMFilePullDataRsp::clear_offset() {
  offset_ = 0u;
  clear_has_offset();
}
inline ::google::protobuf::uint32 IMFilePullDataRsp::offset() const {
  return offset_;
}
inline void IMFilePullDataRsp::set_offset(::google::protobuf::uint32 value) {
  set_has_offset();
  offset_ = value;
}

// required bytes data = 5;
inline bool IMFilePullDataRsp::has_data() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void IMFilePullDataRsp::set_has_data() {
  _has_bits_[0] |= 0x00000010u;
}
inline void IMFilePullDataRsp::clear_has_data() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void IMFilePullDataRsp::clear_data() {
  if (data_ != &::google::protobuf::internal::kEmptyString) {
    data_->clear();
  }
  clear_has_data();
}
inline const ::std::string& IMFilePullDataRsp::data() const {
  return *data_;
}
inline void IMFilePullDataRsp::set_data(const ::std::string& value) {
  set_has_data();
  if (data_ == &::google::protobuf::internal::kEmptyString) {
    data_ = new ::std::string;
  }
  data_->assign(value);
}
inline void IMFilePullDataRsp::set_data(const char* value) {
  set_has_data();
  if (data_ == &::google::protobuf::internal::kEmptyString) {
    data_ = new ::std::string;
  }
  data_->assign(value);
}
inline void IMFilePullDataRsp::set_data(const void* value, size_t size) {
  set_has_data();
  if (data_ == &::google::protobuf::internal::kEmptyString) {
    data_ = new ::std::string;
  }
  data_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* IMFilePullDataRsp::mutable_data() {
  set_has_data();
  if (data_ == &::google::protobuf::internal::kEmptyString) {
    data_ = new ::std::string;
  }
  return data_;
}
inline ::std::string* IMFilePullDataRsp::release_data() {
  clear_has_data();
  if (data_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = data_;
    data_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// -------------------------------------------------------------------

// IMFileReq

// required uint32 from_user_id = 1;
inline bool IMFileReq::has_from_user_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void IMFileReq::set_has_from_user_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void IMFileReq::clear_has_from_user_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void IMFileReq::clear_from_user_id() {
  from_user_id_ = 0u;
  clear_has_from_user_id();
}
inline ::google::protobuf::uint32 IMFileReq::from_user_id() const {
  return from_user_id_;
}
inline void IMFileReq::set_from_user_id(::google::protobuf::uint32 value) {
  set_has_from_user_id();
  from_user_id_ = value;
}

// required uint32 to_user_id = 2;
inline bool IMFileReq::has_to_user_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void IMFileReq::set_has_to_user_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void IMFileReq::clear_has_to_user_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void IMFileReq::clear_to_user_id() {
  to_user_id_ = 0u;
  clear_has_to_user_id();
}
inline ::google::protobuf::uint32 IMFileReq::to_user_id() const {
  return to_user_id_;
}
inline void IMFileReq::set_to_user_id(::google::protobuf::uint32 value) {
  set_has_to_user_id();
  to_user_id_ = value;
}

// required string file_name = 3;
inline bool IMFileReq::has_file_name() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void IMFileReq::set_has_file_name() {
  _has_bits_[0] |= 0x00000004u;
}
inline void IMFileReq::clear_has_file_name() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void IMFileReq::clear_file_name() {
  if (file_name_ != &::google::protobuf::internal::kEmptyString) {
    file_name_->clear();
  }
  clear_has_file_name();
}
inline const ::std::string& IMFileReq::file_name() const {
  return *file_name_;
}
inline void IMFileReq::set_file_name(const ::std::string& value) {
  set_has_file_name();
  if (file_name_ == &::google::protobuf::internal::kEmptyString) {
    file_name_ = new ::std::string;
  }
  file_name_->assign(value);
}
inline void IMFileReq::set_file_name(const char* value) {
  set_has_file_name();
  if (file_name_ == &::google::protobuf::internal::kEmptyString) {
    file_name_ = new ::std::string;
  }
  file_name_->assign(value);
}
inline void IMFileReq::set_file_name(const char* value, size_t size) {
  set_has_file_name();
  if (file_name_ == &::google::protobuf::internal::kEmptyString) {
    file_name_ = new ::std::string;
  }
  file_name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* IMFileReq::mutable_file_name() {
  set_has_file_name();
  if (file_name_ == &::google::protobuf::internal::kEmptyString) {
    file_name_ = new ::std::string;
  }
  return file_name_;
}
inline ::std::string* IMFileReq::release_file_name() {
  clear_has_file_name();
  if (file_name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = file_name_;
    file_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// required uint32 file_size = 4;
inline bool IMFileReq::has_file_size() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void IMFileReq::set_has_file_size() {
  _has_bits_[0] |= 0x00000008u;
}
inline void IMFileReq::clear_has_file_size() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void IMFileReq::clear_file_size() {
  file_size_ = 0u;
  clear_has_file_size();
}
inline ::google::protobuf::uint32 IMFileReq::file_size() const {
  return file_size_;
}
inline void IMFileReq::set_file_size(::google::protobuf::uint32 value) {
  set_has_file_size();
  file_size_ = value;
}

// required .IM.BaseDefine.FileType trans_mode = 5;
inline bool IMFileReq::has_trans_mode() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void IMFileReq::set_has_trans_mode() {
  _has_bits_[0] |= 0x00000010u;
}
inline void IMFileReq::clear_has_trans_mode() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void IMFileReq::clear_trans_mode() {
  trans_mode_ = 1;
  clear_has_trans_mode();
}
inline IM::BaseDefine::FileType IMFileReq::trans_mode() const {
  return static_cast< IM::BaseDefine::FileType >(trans_mode_);
}
inline void IMFileReq::set_trans_mode(IM::BaseDefine::FileType value) {
  GOOGLE_DCHECK(IM::BaseDefine::FileType_IsValid(value));
  set_has_trans_mode();
  trans_mode_ = value;
}

// -------------------------------------------------------------------

// IMFileRsp

// required uint32 result_code = 1;
inline bool IMFileRsp::has_result_code() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void IMFileRsp::set_has_result_code() {
  _has_bits_[0] |= 0x00000001u;
}
inline void IMFileRsp::clear_has_result_code() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void IMFileRsp::clear_result_code() {
  result_code_ = 0u;
  clear_has_result_code();
}
inline ::google::protobuf::uint32 IMFileRsp::result_code() const {
  return result_code_;
}
inline void IMFileRsp::set_result_code(::google::protobuf::uint32 value) {
  set_has_result_code();
  result_code_ = value;
}

// required uint32 from_user_id = 2;
inline bool IMFileRsp::has_from_user_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void IMFileRsp::set_has_from_user_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void IMFileRsp::clear_has_from_user_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void IMFileRsp::clear_from_user_id() {
  from_user_id_ = 0u;
  clear_has_from_user_id();
}
inline ::google::protobuf::uint32 IMFileRsp::from_user_id() const {
  return from_user_id_;
}
inline void IMFileRsp::set_from_user_id(::google::protobuf::uint32 value) {
  set_has_from_user_id();
  from_user_id_ = value;
}

// required uint32 to_user_id = 3;
inline bool IMFileRsp::has_to_user_id() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void IMFileRsp::set_has_to_user_id() {
  _has_bits_[0] |= 0x00000004u;
}
inline void IMFileRsp::clear_has_to_user_id() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void IMFileRsp::clear_to_user_id() {
  to_user_id_ = 0u;
  clear_has_to_user_id();
}
inline ::google::protobuf::uint32 IMFileRsp::to_user_id() const {
  return to_user_id_;
}
inline void IMFileRsp::set_to_user_id(::google::protobuf::uint32 value) {
  set_has_to_user_id();
  to_user_id_ = value;
}

// required string file_name = 4;
inline bool IMFileRsp::has_file_name() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void IMFileRsp::set_has_file_name() {
  _has_bits_[0] |= 0x00000008u;
}
inline void IMFileRsp::clear_has_file_name() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void IMFileRsp::clear_file_name() {
  if (file_name_ != &::google::protobuf::internal::kEmptyString) {
    file_name_->clear();
  }
  clear_has_file_name();
}
inline const ::std::string& IMFileRsp::file_name() const {
  return *file_name_;
}
inline void IMFileRsp::set_file_name(const ::std::string& value) {
  set_has_file_name();
  if (file_name_ == &::google::protobuf::internal::kEmptyString) {
    file_name_ = new ::std::string;
  }
  file_name_->assign(value);
}
inline void IMFileRsp::set_file_name(const char* value) {
  set_has_file_name();
  if (file_name_ == &::google::protobuf::internal::kEmptyString) {
    file_name_ = new ::std::string;
  }
  file_name_->assign(value);
}
inline void IMFileRsp::set_file_name(const char* value, size_t size) {
  set_has_file_name();
  if (file_name_ == &::google::protobuf::internal::kEmptyString) {
    file_name_ = new ::std::string;
  }
  file_name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* IMFileRsp::mutable_file_name() {
  set_has_file_name();
  if (file_name_ == &::google::protobuf::internal::kEmptyString) {
    file_name_ = new ::std::string;
  }
  return file_name_;
}
inline ::std::string* IMFileRsp::release_file_name() {
  clear_has_file_name();
  if (file_name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = file_name_;
    file_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// required string task_id = 5;
inline bool IMFileRsp::has_task_id() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void IMFileRsp::set_has_task_id() {
  _has_bits_[0] |= 0x00000010u;
}
inline void IMFileRsp::clear_has_task_id() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void IMFileRsp::clear_task_id() {
  if (task_id_ != &::google::protobuf::internal::kEmptyString) {
    task_id_->clear();
  }
  clear_has_task_id();
}
inline const ::std::string& IMFileRsp::task_id() const {
  return *task_id_;
}
inline void IMFileRsp::set_task_id(const ::std::string& value) {
  set_has_task_id();
  if (task_id_ == &::google::protobuf::internal::kEmptyString) {
    task_id_ = new ::std::string;
  }
  task_id_->assign(value);
}
inline void IMFileRsp::set_task_id(const char* value) {
  set_has_task_id();
  if (task_id_ == &::google::protobuf::internal::kEmptyString) {
    task_id_ = new ::std::string;
  }
  task_id_->assign(value);
}
inline void IMFileRsp::set_task_id(const char* value, size_t size) {
  set_has_task_id();
  if (task_id_ == &::google::protobuf::internal::kEmptyString) {
    task_id_ = new ::std::string;
  }
  task_id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* IMFileRsp::mutable_task_id() {
  set_has_task_id();
  if (task_id_ == &::google::protobuf::internal::kEmptyString) {
    task_id_ = new ::std::string;
  }
  return task_id_;
}
inline ::std::string* IMFileRsp::release_task_id() {
  clear_has_task_id();
  if (task_id_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = task_id_;
    task_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// repeated .IM.BaseDefine.IpAddr ip_addr_list = 6;
inline int IMFileRsp::ip_addr_list_size() const {
  return ip_addr_list_.size();
}
inline void IMFileRsp::clear_ip_addr_list() {
  ip_addr_list_.Clear();
}
inline const ::IM::BaseDefine::IpAddr& IMFileRsp::ip_addr_list(int index) const {
  return ip_addr_list_.Get(index);
}
inline ::IM::BaseDefine::IpAddr* IMFileRsp::mutable_ip_addr_list(int index) {
  return ip_addr_list_.Mutable(index);
}
inline ::IM::BaseDefine::IpAddr* IMFileRsp::add_ip_addr_list() {
  return ip_addr_list_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::IM::BaseDefine::IpAddr >&
IMFileRsp::ip_addr_list() const {
  return ip_addr_list_;
}
inline ::google::protobuf::RepeatedPtrField< ::IM::BaseDefine::IpAddr >*
IMFileRsp::mutable_ip_addr_list() {
  return &ip_addr_list_;
}

// required .IM.BaseDefine.FileType trans_mode = 7;
inline bool IMFileRsp::has_trans_mode() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void IMFileRsp::set_has_trans_mode() {
  _has_bits_[0] |= 0x00000040u;
}
inline void IMFileRsp::clear_has_trans_mode() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void IMFileRsp::clear_trans_mode() {
  trans_mode_ = 1;
  clear_has_trans_mode();
}
inline IM::BaseDefine::FileType IMFileRsp::trans_mode() const {
  return static_cast< IM::BaseDefine::FileType >(trans_mode_);
}
inline void IMFileRsp::set_trans_mode(IM::BaseDefine::FileType value) {
  GOOGLE_DCHECK(IM::BaseDefine::FileType_IsValid(value));
  set_has_trans_mode();
  trans_mode_ = value;
}

// -------------------------------------------------------------------

// IMFileNotify

// required uint32 from_user_id = 1;
inline bool IMFileNotify::has_from_user_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void IMFileNotify::set_has_from_user_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void IMFileNotify::clear_has_from_user_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void IMFileNotify::clear_from_user_id() {
  from_user_id_ = 0u;
  clear_has_from_user_id();
}
inline ::google::protobuf::uint32 IMFileNotify::from_user_id() const {
  return from_user_id_;
}
inline void IMFileNotify::set_from_user_id(::google::protobuf::uint32 value) {
  set_has_from_user_id();
  from_user_id_ = value;
}

// required uint32 to_user_id = 2;
inline bool IMFileNotify::has_to_user_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void IMFileNotify::set_has_to_user_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void IMFileNotify::clear_has_to_user_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void IMFileNotify::clear_to_user_id() {
  to_user_id_ = 0u;
  clear_has_to_user_id();
}
inline ::google::protobuf::uint32 IMFileNotify::to_user_id() const {
  return to_user_id_;
}
inline void IMFileNotify::set_to_user_id(::google::protobuf::uint32 value) {
  set_has_to_user_id();
  to_user_id_ = value;
}

// required string file_name = 3;
inline bool IMFileNotify::has_file_name() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void IMFileNotify::set_has_file_name() {
  _has_bits_[0] |= 0x00000004u;
}
inline void IMFileNotify::clear_has_file_name() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void IMFileNotify::clear_file_name() {
  if (file_name_ != &::google::protobuf::internal::kEmptyString) {
    file_name_->clear();
  }
  clear_has_file_name();
}
inline const ::std::string& IMFileNotify::file_name() const {
  return *file_name_;
}
inline void IMFileNotify::set_file_name(const ::std::string& value) {
  set_has_file_name();
  if (file_name_ == &::google::protobuf::internal::kEmptyString) {
    file_name_ = new ::std::string;
  }
  file_name_->assign(value);
}
inline void IMFileNotify::set_file_name(const char* value) {
  set_has_file_name();
  if (file_name_ == &::google::protobuf::internal::kEmptyString) {
    file_name_ = new ::std::string;
  }
  file_name_->assign(value);
}
inline void IMFileNotify::set_file_name(const char* value, size_t size) {
  set_has_file_name();
  if (file_name_ == &::google::protobuf::internal::kEmptyString) {
    file_name_ = new ::std::string;
  }
  file_name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* IMFileNotify::mutable_file_name() {
  set_has_file_name();
  if (file_name_ == &::google::protobuf::internal::kEmptyString) {
    file_name_ = new ::std::string;
  }
  return file_name_;
}
inline ::std::string* IMFileNotify::release_file_name() {
  clear_has_file_name();
  if (file_name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = file_name_;
    file_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// required uint32 file_size = 4;
inline bool IMFileNotify::has_file_size() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void IMFileNotify::set_has_file_size() {
  _has_bits_[0] |= 0x00000008u;
}
inline void IMFileNotify::clear_has_file_size() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void IMFileNotify::clear_file_size() {
  file_size_ = 0u;
  clear_has_file_size();
}
inline ::google::protobuf::uint32 IMFileNotify::file_size() const {
  return file_size_;
}
inline void IMFileNotify::set_file_size(::google::protobuf::uint32 value) {
  set_has_file_size();
  file_size_ = value;
}

// required string task_id = 5;
inline bool IMFileNotify::has_task_id() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void IMFileNotify::set_has_task_id() {
  _has_bits_[0] |= 0x00000010u;
}
inline void IMFileNotify::clear_has_task_id() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void IMFileNotify::clear_task_id() {
  if (task_id_ != &::google::protobuf::internal::kEmptyString) {
    task_id_->clear();
  }
  clear_has_task_id();
}
inline const ::std::string& IMFileNotify::task_id() const {
  return *task_id_;
}
inline void IMFileNotify::set_task_id(const ::std::string& value) {
  set_has_task_id();
  if (task_id_ == &::google::protobuf::internal::kEmptyString) {
    task_id_ = new ::std::string;
  }
  task_id_->assign(value);
}
inline void IMFileNotify::set_task_id(const char* value) {
  set_has_task_id();
  if (task_id_ == &::google::protobuf::internal::kEmptyString) {
    task_id_ = new ::std::string;
  }
  task_id_->assign(value);
}
inline void IMFileNotify::set_task_id(const char* value, size_t size) {
  set_has_task_id();
  if (task_id_ == &::google::protobuf::internal::kEmptyString) {
    task_id_ = new ::std::string;
  }
  task_id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* IMFileNotify::mutable_task_id() {
  set_has_task_id();
  if (task_id_ == &::google::protobuf::internal::kEmptyString) {
    task_id_ = new ::std::string;
  }
  return task_id_;
}
inline ::std::string* IMFileNotify::release_task_id() {
  clear_has_task_id();
  if (task_id_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = task_id_;
    task_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// repeated .IM.BaseDefine.IpAddr ip_addr_list = 6;
inline int IMFileNotify::ip_addr_list_size() const {
  return ip_addr_list_.size();
}
inline void IMFileNotify::clear_ip_addr_list() {
  ip_addr_list_.Clear();
}
inline const ::IM::BaseDefine::IpAddr& IMFileNotify::ip_addr_list(int index) const {
  return ip_addr_list_.Get(index);
}
inline ::IM::BaseDefine::IpAddr* IMFileNotify::mutable_ip_addr_list(int index) {
  return ip_addr_list_.Mutable(index);
}
inline ::IM::BaseDefine::IpAddr* IMFileNotify::add_ip_addr_list() {
  return ip_addr_list_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::IM::BaseDefine::IpAddr >&
IMFileNotify::ip_addr_list() const {
  return ip_addr_list_;
}
inline ::google::protobuf::RepeatedPtrField< ::IM::BaseDefine::IpAddr >*
IMFileNotify::mutable_ip_addr_list() {
  return &ip_addr_list_;
}

// required .IM.BaseDefine.FileType trans_mode = 7;
inline bool IMFileNotify::has_trans_mode() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void IMFileNotify::set_has_trans_mode() {
  _has_bits_[0] |= 0x00000040u;
}
inline void IMFileNotify::clear_has_trans_mode() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void IMFileNotify::clear_trans_mode() {
  trans_mode_ = 1;
  clear_has_trans_mode();
}
inline IM::BaseDefine::FileType IMFileNotify::trans_mode() const {
  return static_cast< IM::BaseDefine::FileType >(trans_mode_);
}
inline void IMFileNotify::set_trans_mode(IM::BaseDefine::FileType value) {
  GOOGLE_DCHECK(IM::BaseDefine::FileType_IsValid(value));
  set_has_trans_mode();
  trans_mode_ = value;
}

// required uint32 offline_ready = 8;
inline bool IMFileNotify::has_offline_ready() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void IMFileNotify::set_has_offline_ready() {
  _has_bits_[0] |= 0x00000080u;
}
inline void IMFileNotify::clear_has_offline_ready() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void IMFileNotify::clear_offline_ready() {
  offline_ready_ = 0u;
  clear_has_offline_ready();
}
inline ::google::protobuf::uint32 IMFileNotify::offline_ready() const {
  return offline_ready_;
}
inline void IMFileNotify::set_offline_ready(::google::protobuf::uint32 value) {
  set_has_offline_ready();
  offline_ready_ = value;
}

// -------------------------------------------------------------------

// IMFileHasOfflineReq

// required uint32 user_id = 1;
inline bool IMFileHasOfflineReq::has_user_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void IMFileHasOfflineReq::set_has_user_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void IMFileHasOfflineReq::clear_has_user_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void IMFileHasOfflineReq::clear_user_id() {
  user_id_ = 0u;
  clear_has_user_id();
}
inline ::google::protobuf::uint32 IMFileHasOfflineReq::user_id() const {
  return user_id_;
}
inline void IMFileHasOfflineReq::set_user_id(::google::protobuf::uint32 value) {
  set_has_user_id();
  user_id_ = value;
}

// optional bytes attach_data = 20;
inline bool IMFileHasOfflineReq::has_attach_data() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void IMFileHasOfflineReq::set_has_attach_data() {
  _has_bits_[0] |= 0x00000002u;
}
inline void IMFileHasOfflineReq::clear_has_attach_data() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void IMFileHasOfflineReq::clear_attach_data() {
  if (attach_data_ != &::google::protobuf::internal::kEmptyString) {
    attach_data_->clear();
  }
  clear_has_attach_data();
}
inline const ::std::string& IMFileHasOfflineReq::attach_data() const {
  return *attach_data_;
}
inline void IMFileHasOfflineReq::set_attach_data(const ::std::string& value) {
  set_has_attach_data();
  if (attach_data_ == &::google::protobuf::internal::kEmptyString) {
    attach_data_ = new ::std::string;
  }
  attach_data_->assign(value);
}
inline void IMFileHasOfflineReq::set_attach_data(const char* value) {
  set_has_attach_data();
  if (attach_data_ == &::google::protobuf::internal::kEmptyString) {
    attach_data_ = new ::std::string;
  }
  attach_data_->assign(value);
}
inline void IMFileHasOfflineReq::set_attach_data(const void* value, size_t size) {
  set_has_attach_data();
  if (attach_data_ == &::google::protobuf::internal::kEmptyString) {
    attach_data_ = new ::std::string;
  }
  attach_data_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* IMFileHasOfflineReq::mutable_attach_data() {
  set_has_attach_data();
  if (attach_data_ == &::google::protobuf::internal::kEmptyString) {
    attach_data_ = new ::std::string;
  }
  return attach_data_;
}
inline ::std::string* IMFileHasOfflineReq::release_attach_data() {
  clear_has_attach_data();
  if (attach_data_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = attach_data_;
    attach_data_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// -------------------------------------------------------------------

// IMFileHasOfflineRsp

// required uint32 user_id = 1;
inline bool IMFileHasOfflineRsp::has_user_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void IMFileHasOfflineRsp::set_has_user_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void IMFileHasOfflineRsp::clear_has_user_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void IMFileHasOfflineRsp::clear_user_id() {
  user_id_ = 0u;
  clear_has_user_id();
}
inline ::google::protobuf::uint32 IMFileHasOfflineRsp::user_id() const {
  return user_id_;
}
inline void IMFileHasOfflineRsp::set_user_id(::google::protobuf::uint32 value) {
  set_has_user_id();
  user_id_ = value;
}

// repeated .IM.BaseDefine.OfflineFileInfo offline_file_list = 2;
inline int IMFileHasOfflineRsp::offline_file_list_size() const {
  return offline_file_list_.size();
}
inline void IMFileHasOfflineRsp::clear_offline_file_list() {
  offline_file_list_.Clear();
}
inline const ::IM::BaseDefine::OfflineFileInfo& IMFileHasOfflineRsp::offline_file_list(int index) const {
  return offline_file_list_.Get(index);
}
inline ::IM::BaseDefine::OfflineFileInfo* IMFileHasOfflineRsp::mutable_offline_file_list(int index) {
  return offline_file_list_.Mutable(index);
}
inline ::IM::BaseDefine::OfflineFileInfo* IMFileHasOfflineRsp::add_offline_file_list() {
  return offline_file_list_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::IM::BaseDefine::OfflineFileInfo >&
IMFileHasOfflineRsp::offline_file_list() const {
  return offline_file_list_;
}
inline ::google::protobuf::RepeatedPtrField< ::IM::BaseDefine::OfflineFileInfo >*
IMFileHasOfflineRsp::mutable_offline_file_list() {
  return &offline_file_list_;
}

// repeated .IM.BaseDefine.IpAddr ip_addr_list = 3;
inline int IMFileHasOfflineRsp::ip_addr_list_size() const {
  return ip_addr_list_.size();
}
inline void IMFileHasOfflineRsp::clear_ip_addr_list() {
  ip_addr_list_.Clear();
}
inline const ::IM::BaseDefine::IpAddr& IMFileHasOfflineRsp::ip_addr_list(int index) const {
  return ip_addr_list_.Get(index);
}
inline ::IM::BaseDefine::IpAddr* IMFileHasOfflineRsp::mutable_ip_addr_list(int index) {
  return ip_addr_list_.Mutable(index);
}
inline ::IM::BaseDefine::IpAddr* IMFileHasOfflineRsp::add_ip_addr_list() {
  return ip_addr_list_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::IM::BaseDefine::IpAddr >&
IMFileHasOfflineRsp::ip_addr_list() const {
  return ip_addr_list_;
}
inline ::google::protobuf::RepeatedPtrField< ::IM::BaseDefine::IpAddr >*
IMFileHasOfflineRsp::mutable_ip_addr_list() {
  return &ip_addr_list_;
}

// optional bytes attach_data = 20;
inline bool IMFileHasOfflineRsp::has_attach_data() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void IMFileHasOfflineRsp::set_has_attach_data() {
  _has_bits_[0] |= 0x00000008u;
}
inline void IMFileHasOfflineRsp::clear_has_attach_data() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void IMFileHasOfflineRsp::clear_attach_data() {
  if (attach_data_ != &::google::protobuf::internal::kEmptyString) {
    attach_data_->clear();
  }
  clear_has_attach_data();
}
inline const ::std::string& IMFileHasOfflineRsp::attach_data() const {
  return *attach_data_;
}
inline void IMFileHasOfflineRsp::set_attach_data(const ::std::string& value) {
  set_has_attach_data();
  if (attach_data_ == &::google::protobuf::internal::kEmptyString) {
    attach_data_ = new ::std::string;
  }
  attach_data_->assign(value);
}
inline void IMFileHasOfflineRsp::set_attach_data(const char* value) {
  set_has_attach_data();
  if (attach_data_ == &::google::protobuf::internal::kEmptyString) {
    attach_data_ = new ::std::string;
  }
  attach_data_->assign(value);
}
inline void IMFileHasOfflineRsp::set_attach_data(const void* value, size_t size) {
  set_has_attach_data();
  if (attach_data_ == &::google::protobuf::internal::kEmptyString) {
    attach_data_ = new ::std::string;
  }
  attach_data_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* IMFileHasOfflineRsp::mutable_attach_data() {
  set_has_attach_data();
  if (attach_data_ == &::google::protobuf::internal::kEmptyString) {
    attach_data_ = new ::std::string;
  }
  return attach_data_;
}
inline ::std::string* IMFileHasOfflineRsp::release_attach_data() {
  clear_has_attach_data();
  if (attach_data_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = attach_data_;
    attach_data_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// -------------------------------------------------------------------

// IMFileAddOfflineReq

// required uint32 from_user_id = 1;
inline bool IMFileAddOfflineReq::has_from_user_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void IMFileAddOfflineReq::set_has_from_user_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void IMFileAddOfflineReq::clear_has_from_user_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void IMFileAddOfflineReq::clear_from_user_id() {
  from_user_id_ = 0u;
  clear_has_from_user_id();
}
inline ::google::protobuf::uint32 IMFileAddOfflineReq::from_user_id() const {
  return from_user_id_;
}
inline void IMFileAddOfflineReq::set_from_user_id(::google::protobuf::uint32 value) {
  set_has_from_user_id();
  from_user_id_ = value;
}

// required uint32 to_user_id = 2;
inline bool IMFileAddOfflineReq::has_to_user_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void IMFileAddOfflineReq::set_has_to_user_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void IMFileAddOfflineReq::clear_has_to_user_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void IMFileAddOfflineReq::clear_to_user_id() {
  to_user_id_ = 0u;
  clear_has_to_user_id();
}
inline ::google::protobuf::uint32 IMFileAddOfflineReq::to_user_id() const {
  return to_user_id_;
}
inline void IMFileAddOfflineReq::set_to_user_id(::google::protobuf::uint32 value) {
  set_has_to_user_id();
  to_user_id_ = value;
}

// required string task_id = 3;
inline bool IMFileAddOfflineReq::has_task_id() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void IMFileAddOfflineReq::set_has_task_id() {
  _has_bits_[0] |= 0x00000004u;
}
inline void IMFileAddOfflineReq::clear_has_task_id() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void IMFileAddOfflineReq::clear_task_id() {
  if (task_id_ != &::google::protobuf::internal::kEmptyString) {
    task_id_->clear();
  }
  clear_has_task_id();
}
inline const ::std::string& IMFileAddOfflineReq::task_id() const {
  return *task_id_;
}
inline void IMFileAddOfflineReq::set_task_id(const ::std::string& value) {
  set_has_task_id();
  if (task_id_ == &::google::protobuf::internal::kEmptyString) {
    task_id_ = new ::std::string;
  }
  task_id_->assign(value);
}
inline void IMFileAddOfflineReq::set_task_id(const char* value) {
  set_has_task_id();
  if (task_id_ == &::google::protobuf::internal::kEmptyString) {
    task_id_ = new ::std::string;
  }
  task_id_->assign(value);
}
inline void IMFileAddOfflineReq::set_task_id(const char* value, size_t size) {
  set_has_task_id();
  if (task_id_ == &::google::protobuf::internal::kEmptyString) {
    task_id_ = new ::std::string;
  }
  task_id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* IMFileAddOfflineReq::mutable_task_id() {
  set_has_task_id();
  if (task_id_ == &::google::protobuf::internal::kEmptyString) {
    task_id_ = new ::std::string;
  }
  return task_id_;
}
inline ::std::string* IMFileAddOfflineReq::release_task_id() {
  clear_has_task_id();
  if (task_id_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = task_id_;
    task_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// required string file_name = 4;
inline bool IMFileAddOfflineReq::has_file_name() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void IMFileAddOfflineReq::set_has_file_name() {
  _has_bits_[0] |= 0x00000008u;
}
inline void IMFileAddOfflineReq::clear_has_file_name() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void IMFileAddOfflineReq::clear_file_name() {
  if (file_name_ != &::google::protobuf::internal::kEmptyString) {
    file_name_->clear();
  }
  clear_has_file_name();
}
inline const ::std::string& IMFileAddOfflineReq::file_name() const {
  return *file_name_;
}
inline void IMFileAddOfflineReq::set_file_name(const ::std::string& value) {
  set_has_file_name();
  if (file_name_ == &::google::protobuf::internal::kEmptyString) {
    file_name_ = new ::std::string;
  }
  file_name_->assign(value);
}
inline void IMFileAddOfflineReq::set_file_name(const char* value) {
  set_has_file_name();
  if (file_name_ == &::google::protobuf::internal::kEmptyString) {
    file_name_ = new ::std::string;
  }
  file_name_->assign(value);
}
inline void IMFileAddOfflineReq::set_file_name(const char* value, size_t size) {
  set_has_file_name();
  if (file_name_ == &::google::protobuf::internal::kEmptyString) {
    file_name_ = new ::std::string;
  }
  file_name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* IMFileAddOfflineReq::mutable_file_name() {
  set_has_file_name();
  if (file_name_ == &::google::protobuf::internal::kEmptyString) {
    file_name_ = new ::std::string;
  }
  return file_name_;
}
inline ::std::string* IMFileAddOfflineReq::release_file_name() {
  clear_has_file_name();
  if (file_name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = file_name_;
    file_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// required uint32 file_size = 5;
inline bool IMFileAddOfflineReq::has_file_size() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void IMFileAddOfflineReq::set_has_file_size() {
  _has_bits_[0] |= 0x00000010u;
}
inline void IMFileAddOfflineReq::clear_has_file_size() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void IMFileAddOfflineReq::clear_file_size() {
  file_size_ = 0u;
  clear_has_file_size();
}
inline ::google::protobuf::uint32 IMFileAddOfflineReq::file_size() const {
  return file_size_;
}
inline void IMFileAddOfflineReq::set_file_size(::google::protobuf::uint32 value) {
  set_has_file_size();
  file_size_ = value;
}

// -------------------------------------------------------------------

// IMFileDelOfflineReq

// required uint32 from_user_id = 1;
inline bool IMFileDelOfflineReq::has_from_user_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void IMFileDelOfflineReq::set_has_from_user_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void IMFileDelOfflineReq::clear_has_from_user_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void IMFileDelOfflineReq::clear_from_user_id() {
  from_user_id_ = 0u;
  clear_has_from_user_id();
}
inline ::google::protobuf::uint32 IMFileDelOfflineReq::from_user_id() const {
  return from_user_id_;
}
inline void IMFileDelOfflineReq::set_from_user_id(::google::protobuf::uint32 value) {
  set_has_from_user_id();
  from_user_id_ = value;
}

// required uint32 to_user_id = 2;
inline bool IMFileDelOfflineReq::has_to_user_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void IMFileDelOfflineReq::set_has_to_user_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void IMFileDelOfflineReq::clear_has_to_user_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void IMFileDelOfflineReq::clear_to_user_id() {
  to_user_id_ = 0u;
  clear_has_to_user_id();
}
inline ::google::protobuf::uint32 IMFileDelOfflineReq::to_user_id() const {
  return to_user_id_;
}
inline void IMFileDelOfflineReq::set_to_user_id(::google::protobuf::uint32 value) {
  set_has_to_user_id();
  to_user_id_ = value;
}

// required string task_id = 3;
inline bool IMFileDelOfflineReq::has_task_id() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void IMFileDelOfflineReq::set_has_task_id() {
  _has_bits_[0] |= 0x00000004u;
}
inline void IMFileDelOfflineReq::clear_has_task_id() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void IMFileDelOfflineReq::clear_task_id() {
  if (task_id_ != &::google::protobuf::internal::kEmptyString) {
    task_id_->clear();
  }
  clear_has_task_id();
}
inline const ::std::string& IMFileDelOfflineReq::task_id() const {
  return *task_id_;
}
inline void IMFileDelOfflineReq::set_task_id(const ::std::string& value) {
  set_has_task_id();
  if (task_id_ == &::google::protobuf::internal::kEmptyString) {
    task_id_ = new ::std::string;
  }
  task_id_->assign(value);
}
inline void IMFileDelOfflineReq::set_task_id(const char* value) {
  set_has_task_id();
  if (task_id_ == &::google::protobuf::internal::kEmptyString) {
    task_id_ = new ::std::string;
  }
  task_id_->assign(value);
}
inline void IMFileDelOfflineReq::set_task_id(const char* value, size_t size) {
  set_has_task_id();
  if (task_id_ == &::google::protobuf::internal::kEmptyString) {
    task_id_ = new ::std::string;
  }
  task_id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* IMFileDelOfflineReq::mutable_task_id() {
  set_has_task_id();
  if (task_id_ == &::google::protobuf::internal::kEmptyString) {
    task_id_ = new ::std::string;
  }
  return task_id_;
}
inline ::std::string* IMFileDelOfflineReq::release_task_id() {
  clear_has_task_id();
  if (task_id_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = task_id_;
    task_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace File
}  // namespace IM

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_IM_2eFile_2eproto__INCLUDED
