// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: IM.Buddy.proto

#ifndef PROTOBUF_IM_2eBuddy_2eproto__INCLUDED
#define PROTOBUF_IM_2eBuddy_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2004000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2004001 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include "IM.BaseDefine.pb.h"
// @@protoc_insertion_point(includes)

namespace IM {
namespace Buddy {

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_IM_2eBuddy_2eproto();
void protobuf_AssignDesc_IM_2eBuddy_2eproto();
void protobuf_ShutdownFile_IM_2eBuddy_2eproto();

class IMRecentContactSessionReq;
class IMRecentContactSessionRsp;
class IMUserStatNotify;
class IMUsersInfoReq;
class IMUsersInfoRsp;
class IMRemoveSessionReq;
class IMRemoveSessionRsp;
class IMAllUserReq;
class IMAllUserRsp;
class IMUsersStatReq;
class IMUsersStatRsp;
class IMChangeAvatarReq;
class IMChangeAvatarRsp;
class IMPCLoginStatusNotify;
class IMRemoveSessionNotify;
class IMDepartmentReq;
class IMDepartmentRsp;

// ===================================================================

class IMRecentContactSessionReq : public ::google::protobuf::MessageLite {
 public:
  IMRecentContactSessionReq();
  virtual ~IMRecentContactSessionReq();
  
  IMRecentContactSessionReq(const IMRecentContactSessionReq& from);
  
  inline IMRecentContactSessionReq& operator=(const IMRecentContactSessionReq& from) {
    CopyFrom(from);
    return *this;
  }
  
  static const IMRecentContactSessionReq& default_instance();
  
  void Swap(IMRecentContactSessionReq* other);
  
  // implements Message ----------------------------------------------
  
  IMRecentContactSessionReq* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const IMRecentContactSessionReq& from);
  void MergeFrom(const IMRecentContactSessionReq& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::std::string GetTypeName() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required uint32 user_id = 1;
  inline bool has_user_id() const;
  inline void clear_user_id();
  static const int kUserIdFieldNumber = 1;
  inline ::google::protobuf::uint32 user_id() const;
  inline void set_user_id(::google::protobuf::uint32 value);
  
  // required uint32 latest_update_time = 2;
  inline bool has_latest_update_time() const;
  inline void clear_latest_update_time();
  static const int kLatestUpdateTimeFieldNumber = 2;
  inline ::google::protobuf::uint32 latest_update_time() const;
  inline void set_latest_update_time(::google::protobuf::uint32 value);
  
  // optional bytes attach_data = 20;
  inline bool has_attach_data() const;
  inline void clear_attach_data();
  static const int kAttachDataFieldNumber = 20;
  inline const ::std::string& attach_data() const;
  inline void set_attach_data(const ::std::string& value);
  inline void set_attach_data(const char* value);
  inline void set_attach_data(const void* value, size_t size);
  inline ::std::string* mutable_attach_data();
  inline ::std::string* release_attach_data();
  
  // @@protoc_insertion_point(class_scope:IM.Buddy.IMRecentContactSessionReq)
 private:
  inline void set_has_user_id();
  inline void clear_has_user_id();
  inline void set_has_latest_update_time();
  inline void clear_has_latest_update_time();
  inline void set_has_attach_data();
  inline void clear_has_attach_data();
  
  ::google::protobuf::uint32 user_id_;
  ::google::protobuf::uint32 latest_update_time_;
  ::std::string* attach_data_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];
  
  friend void  protobuf_AddDesc_IM_2eBuddy_2eproto();
  friend void protobuf_AssignDesc_IM_2eBuddy_2eproto();
  friend void protobuf_ShutdownFile_IM_2eBuddy_2eproto();
  
  void InitAsDefaultInstance();
  static IMRecentContactSessionReq* default_instance_;
};
// -------------------------------------------------------------------

class IMRecentContactSessionRsp : public ::google::protobuf::MessageLite {
 public:
  IMRecentContactSessionRsp();
  virtual ~IMRecentContactSessionRsp();
  
  IMRecentContactSessionRsp(const IMRecentContactSessionRsp& from);
  
  inline IMRecentContactSessionRsp& operator=(const IMRecentContactSessionRsp& from) {
    CopyFrom(from);
    return *this;
  }
  
  static const IMRecentContactSessionRsp& default_instance();
  
  void Swap(IMRecentContactSessionRsp* other);
  
  // implements Message ----------------------------------------------
  
  IMRecentContactSessionRsp* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const IMRecentContactSessionRsp& from);
  void MergeFrom(const IMRecentContactSessionRsp& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::std::string GetTypeName() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required uint32 user_id = 1;
  inline bool has_user_id() const;
  inline void clear_user_id();
  static const int kUserIdFieldNumber = 1;
  inline ::google::protobuf::uint32 user_id() const;
  inline void set_user_id(::google::protobuf::uint32 value);
  
  // repeated .IM.BaseDefine.ContactSessionInfo contact_session_list = 2;
  inline int contact_session_list_size() const;
  inline void clear_contact_session_list();
  static const int kContactSessionListFieldNumber = 2;
  inline const ::IM::BaseDefine::ContactSessionInfo& contact_session_list(int index) const;
  inline ::IM::BaseDefine::ContactSessionInfo* mutable_contact_session_list(int index);
  inline ::IM::BaseDefine::ContactSessionInfo* add_contact_session_list();
  inline const ::google::protobuf::RepeatedPtrField< ::IM::BaseDefine::ContactSessionInfo >&
      contact_session_list() const;
  inline ::google::protobuf::RepeatedPtrField< ::IM::BaseDefine::ContactSessionInfo >*
      mutable_contact_session_list();
  
  // optional bytes attach_data = 20;
  inline bool has_attach_data() const;
  inline void clear_attach_data();
  static const int kAttachDataFieldNumber = 20;
  inline const ::std::string& attach_data() const;
  inline void set_attach_data(const ::std::string& value);
  inline void set_attach_data(const char* value);
  inline void set_attach_data(const void* value, size_t size);
  inline ::std::string* mutable_attach_data();
  inline ::std::string* release_attach_data();
  
  // @@protoc_insertion_point(class_scope:IM.Buddy.IMRecentContactSessionRsp)
 private:
  inline void set_has_user_id();
  inline void clear_has_user_id();
  inline void set_has_attach_data();
  inline void clear_has_attach_data();
  
  ::google::protobuf::RepeatedPtrField< ::IM::BaseDefine::ContactSessionInfo > contact_session_list_;
  ::std::string* attach_data_;
  ::google::protobuf::uint32 user_id_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];
  
  friend void  protobuf_AddDesc_IM_2eBuddy_2eproto();
  friend void protobuf_AssignDesc_IM_2eBuddy_2eproto();
  friend void protobuf_ShutdownFile_IM_2eBuddy_2eproto();
  
  void InitAsDefaultInstance();
  static IMRecentContactSessionRsp* default_instance_;
};
// -------------------------------------------------------------------

class IMUserStatNotify : public ::google::protobuf::MessageLite {
 public:
  IMUserStatNotify();
  virtual ~IMUserStatNotify();
  
  IMUserStatNotify(const IMUserStatNotify& from);
  
  inline IMUserStatNotify& operator=(const IMUserStatNotify& from) {
    CopyFrom(from);
    return *this;
  }
  
  static const IMUserStatNotify& default_instance();
  
  void Swap(IMUserStatNotify* other);
  
  // implements Message ----------------------------------------------
  
  IMUserStatNotify* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const IMUserStatNotify& from);
  void MergeFrom(const IMUserStatNotify& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::std::string GetTypeName() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required .IM.BaseDefine.UserStat user_stat = 1;
  inline bool has_user_stat() const;
  inline void clear_user_stat();
  static const int kUserStatFieldNumber = 1;
  inline const ::IM::BaseDefine::UserStat& user_stat() const;
  inline ::IM::BaseDefine::UserStat* mutable_user_stat();
  inline ::IM::BaseDefine::UserStat* release_user_stat();
  
  // @@protoc_insertion_point(class_scope:IM.Buddy.IMUserStatNotify)
 private:
  inline void set_has_user_stat();
  inline void clear_has_user_stat();
  
  ::IM::BaseDefine::UserStat* user_stat_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];
  
  friend void  protobuf_AddDesc_IM_2eBuddy_2eproto();
  friend void protobuf_AssignDesc_IM_2eBuddy_2eproto();
  friend void protobuf_ShutdownFile_IM_2eBuddy_2eproto();
  
  void InitAsDefaultInstance();
  static IMUserStatNotify* default_instance_;
};
// -------------------------------------------------------------------

class IMUsersInfoReq : public ::google::protobuf::MessageLite {
 public:
  IMUsersInfoReq();
  virtual ~IMUsersInfoReq();
  
  IMUsersInfoReq(const IMUsersInfoReq& from);
  
  inline IMUsersInfoReq& operator=(const IMUsersInfoReq& from) {
    CopyFrom(from);
    return *this;
  }
  
  static const IMUsersInfoReq& default_instance();
  
  void Swap(IMUsersInfoReq* other);
  
  // implements Message ----------------------------------------------
  
  IMUsersInfoReq* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const IMUsersInfoReq& from);
  void MergeFrom(const IMUsersInfoReq& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::std::string GetTypeName() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required uint32 user_id = 1;
  inline bool has_user_id() const;
  inline void clear_user_id();
  static const int kUserIdFieldNumber = 1;
  inline ::google::protobuf::uint32 user_id() const;
  inline void set_user_id(::google::protobuf::uint32 value);
  
  // repeated uint32 user_id_list = 2;
  inline int user_id_list_size() const;
  inline void clear_user_id_list();
  static const int kUserIdListFieldNumber = 2;
  inline ::google::protobuf::uint32 user_id_list(int index) const;
  inline void set_user_id_list(int index, ::google::protobuf::uint32 value);
  inline void add_user_id_list(::google::protobuf::uint32 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
      user_id_list() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
      mutable_user_id_list();
  
  // optional bytes attach_data = 20;
  inline bool has_attach_data() const;
  inline void clear_attach_data();
  static const int kAttachDataFieldNumber = 20;
  inline const ::std::string& attach_data() const;
  inline void set_attach_data(const ::std::string& value);
  inline void set_attach_data(const char* value);
  inline void set_attach_data(const void* value, size_t size);
  inline ::std::string* mutable_attach_data();
  inline ::std::string* release_attach_data();
  
  // @@protoc_insertion_point(class_scope:IM.Buddy.IMUsersInfoReq)
 private:
  inline void set_has_user_id();
  inline void clear_has_user_id();
  inline void set_has_attach_data();
  inline void clear_has_attach_data();
  
  ::google::protobuf::RepeatedField< ::google::protobuf::uint32 > user_id_list_;
  ::std::string* attach_data_;
  ::google::protobuf::uint32 user_id_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];
  
  friend void  protobuf_AddDesc_IM_2eBuddy_2eproto();
  friend void protobuf_AssignDesc_IM_2eBuddy_2eproto();
  friend void protobuf_ShutdownFile_IM_2eBuddy_2eproto();
  
  void InitAsDefaultInstance();
  static IMUsersInfoReq* default_instance_;
};
// -------------------------------------------------------------------

class IMUsersInfoRsp : public ::google::protobuf::MessageLite {
 public:
  IMUsersInfoRsp();
  virtual ~IMUsersInfoRsp();
  
  IMUsersInfoRsp(const IMUsersInfoRsp& from);
  
  inline IMUsersInfoRsp& operator=(const IMUsersInfoRsp& from) {
    CopyFrom(from);
    return *this;
  }
  
  static const IMUsersInfoRsp& default_instance();
  
  void Swap(IMUsersInfoRsp* other);
  
  // implements Message ----------------------------------------------
  
  IMUsersInfoRsp* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const IMUsersInfoRsp& from);
  void MergeFrom(const IMUsersInfoRsp& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::std::string GetTypeName() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required uint32 user_id = 1;
  inline bool has_user_id() const;
  inline void clear_user_id();
  static const int kUserIdFieldNumber = 1;
  inline ::google::protobuf::uint32 user_id() const;
  inline void set_user_id(::google::protobuf::uint32 value);
  
  // repeated .IM.BaseDefine.UserInfo user_info_list = 2;
  inline int user_info_list_size() const;
  inline void clear_user_info_list();
  static const int kUserInfoListFieldNumber = 2;
  inline const ::IM::BaseDefine::UserInfo& user_info_list(int index) const;
  inline ::IM::BaseDefine::UserInfo* mutable_user_info_list(int index);
  inline ::IM::BaseDefine::UserInfo* add_user_info_list();
  inline const ::google::protobuf::RepeatedPtrField< ::IM::BaseDefine::UserInfo >&
      user_info_list() const;
  inline ::google::protobuf::RepeatedPtrField< ::IM::BaseDefine::UserInfo >*
      mutable_user_info_list();
  
  // optional bytes attach_data = 20;
  inline bool has_attach_data() const;
  inline void clear_attach_data();
  static const int kAttachDataFieldNumber = 20;
  inline const ::std::string& attach_data() const;
  inline void set_attach_data(const ::std::string& value);
  inline void set_attach_data(const char* value);
  inline void set_attach_data(const void* value, size_t size);
  inline ::std::string* mutable_attach_data();
  inline ::std::string* release_attach_data();
  
  // @@protoc_insertion_point(class_scope:IM.Buddy.IMUsersInfoRsp)
 private:
  inline void set_has_user_id();
  inline void clear_has_user_id();
  inline void set_has_attach_data();
  inline void clear_has_attach_data();
  
  ::google::protobuf::RepeatedPtrField< ::IM::BaseDefine::UserInfo > user_info_list_;
  ::std::string* attach_data_;
  ::google::protobuf::uint32 user_id_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];
  
  friend void  protobuf_AddDesc_IM_2eBuddy_2eproto();
  friend void protobuf_AssignDesc_IM_2eBuddy_2eproto();
  friend void protobuf_ShutdownFile_IM_2eBuddy_2eproto();
  
  void InitAsDefaultInstance();
  static IMUsersInfoRsp* default_instance_;
};
// -------------------------------------------------------------------

class IMRemoveSessionReq : public ::google::protobuf::MessageLite {
 public:
  IMRemoveSessionReq();
  virtual ~IMRemoveSessionReq();
  
  IMRemoveSessionReq(const IMRemoveSessionReq& from);
  
  inline IMRemoveSessionReq& operator=(const IMRemoveSessionReq& from) {
    CopyFrom(from);
    return *this;
  }
  
  static const IMRemoveSessionReq& default_instance();
  
  void Swap(IMRemoveSessionReq* other);
  
  // implements Message ----------------------------------------------
  
  IMRemoveSessionReq* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const IMRemoveSessionReq& from);
  void MergeFrom(const IMRemoveSessionReq& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::std::string GetTypeName() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required uint32 user_id = 1;
  inline bool has_user_id() const;
  inline void clear_user_id();
  static const int kUserIdFieldNumber = 1;
  inline ::google::protobuf::uint32 user_id() const;
  inline void set_user_id(::google::protobuf::uint32 value);
  
  // required .IM.BaseDefine.SessionType session_type = 2;
  inline bool has_session_type() const;
  inline void clear_session_type();
  static const int kSessionTypeFieldNumber = 2;
  inline IM::BaseDefine::SessionType session_type() const;
  inline void set_session_type(IM::BaseDefine::SessionType value);
  
  // required uint32 session_id = 3;
  inline bool has_session_id() const;
  inline void clear_session_id();
  static const int kSessionIdFieldNumber = 3;
  inline ::google::protobuf::uint32 session_id() const;
  inline void set_session_id(::google::protobuf::uint32 value);
  
  // optional bytes attach_data = 20;
  inline bool has_attach_data() const;
  inline void clear_attach_data();
  static const int kAttachDataFieldNumber = 20;
  inline const ::std::string& attach_data() const;
  inline void set_attach_data(const ::std::string& value);
  inline void set_attach_data(const char* value);
  inline void set_attach_data(const void* value, size_t size);
  inline ::std::string* mutable_attach_data();
  inline ::std::string* release_attach_data();
  
  // @@protoc_insertion_point(class_scope:IM.Buddy.IMRemoveSessionReq)
 private:
  inline void set_has_user_id();
  inline void clear_has_user_id();
  inline void set_has_session_type();
  inline void clear_has_session_type();
  inline void set_has_session_id();
  inline void clear_has_session_id();
  inline void set_has_attach_data();
  inline void clear_has_attach_data();
  
  ::google::protobuf::uint32 user_id_;
  int session_type_;
  ::std::string* attach_data_;
  ::google::protobuf::uint32 session_id_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];
  
  friend void  protobuf_AddDesc_IM_2eBuddy_2eproto();
  friend void protobuf_AssignDesc_IM_2eBuddy_2eproto();
  friend void protobuf_ShutdownFile_IM_2eBuddy_2eproto();
  
  void InitAsDefaultInstance();
  static IMRemoveSessionReq* default_instance_;
};
// -------------------------------------------------------------------

class IMRemoveSessionRsp : public ::google::protobuf::MessageLite {
 public:
  IMRemoveSessionRsp();
  virtual ~IMRemoveSessionRsp();
  
  IMRemoveSessionRsp(const IMRemoveSessionRsp& from);
  
  inline IMRemoveSessionRsp& operator=(const IMRemoveSessionRsp& from) {
    CopyFrom(from);
    return *this;
  }
  
  static const IMRemoveSessionRsp& default_instance();
  
  void Swap(IMRemoveSessionRsp* other);
  
  // implements Message ----------------------------------------------
  
  IMRemoveSessionRsp* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const IMRemoveSessionRsp& from);
  void MergeFrom(const IMRemoveSessionRsp& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::std::string GetTypeName() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required uint32 user_id = 1;
  inline bool has_user_id() const;
  inline void clear_user_id();
  static const int kUserIdFieldNumber = 1;
  inline ::google::protobuf::uint32 user_id() const;
  inline void set_user_id(::google::protobuf::uint32 value);
  
  // required uint32 result_code = 2;
  inline bool has_result_code() const;
  inline void clear_result_code();
  static const int kResultCodeFieldNumber = 2;
  inline ::google::protobuf::uint32 result_code() const;
  inline void set_result_code(::google::protobuf::uint32 value);
  
  // required .IM.BaseDefine.SessionType session_type = 3;
  inline bool has_session_type() const;
  inline void clear_session_type();
  static const int kSessionTypeFieldNumber = 3;
  inline IM::BaseDefine::SessionType session_type() const;
  inline void set_session_type(IM::BaseDefine::SessionType value);
  
  // required uint32 session_id = 4;
  inline bool has_session_id() const;
  inline void clear_session_id();
  static const int kSessionIdFieldNumber = 4;
  inline ::google::protobuf::uint32 session_id() const;
  inline void set_session_id(::google::protobuf::uint32 value);
  
  // optional bytes attach_data = 20;
  inline bool has_attach_data() const;
  inline void clear_attach_data();
  static const int kAttachDataFieldNumber = 20;
  inline const ::std::string& attach_data() const;
  inline void set_attach_data(const ::std::string& value);
  inline void set_attach_data(const char* value);
  inline void set_attach_data(const void* value, size_t size);
  inline ::std::string* mutable_attach_data();
  inline ::std::string* release_attach_data();
  
  // @@protoc_insertion_point(class_scope:IM.Buddy.IMRemoveSessionRsp)
 private:
  inline void set_has_user_id();
  inline void clear_has_user_id();
  inline void set_has_result_code();
  inline void clear_has_result_code();
  inline void set_has_session_type();
  inline void clear_has_session_type();
  inline void set_has_session_id();
  inline void clear_has_session_id();
  inline void set_has_attach_data();
  inline void clear_has_attach_data();
  
  ::google::protobuf::uint32 user_id_;
  ::google::protobuf::uint32 result_code_;
  int session_type_;
  ::google::protobuf::uint32 session_id_;
  ::std::string* attach_data_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];
  
  friend void  protobuf_AddDesc_IM_2eBuddy_2eproto();
  friend void protobuf_AssignDesc_IM_2eBuddy_2eproto();
  friend void protobuf_ShutdownFile_IM_2eBuddy_2eproto();
  
  void InitAsDefaultInstance();
  static IMRemoveSessionRsp* default_instance_;
};
// -------------------------------------------------------------------

class IMAllUserReq : public ::google::protobuf::MessageLite {
 public:
  IMAllUserReq();
  virtual ~IMAllUserReq();
  
  IMAllUserReq(const IMAllUserReq& from);
  
  inline IMAllUserReq& operator=(const IMAllUserReq& from) {
    CopyFrom(from);
    return *this;
  }
  
  static const IMAllUserReq& default_instance();
  
  void Swap(IMAllUserReq* other);
  
  // implements Message ----------------------------------------------
  
  IMAllUserReq* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const IMAllUserReq& from);
  void MergeFrom(const IMAllUserReq& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::std::string GetTypeName() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required uint32 user_id = 1;
  inline bool has_user_id() const;
  inline void clear_user_id();
  static const int kUserIdFieldNumber = 1;
  inline ::google::protobuf::uint32 user_id() const;
  inline void set_user_id(::google::protobuf::uint32 value);
  
  // required uint32 latest_update_time = 2;
  inline bool has_latest_update_time() const;
  inline void clear_latest_update_time();
  static const int kLatestUpdateTimeFieldNumber = 2;
  inline ::google::protobuf::uint32 latest_update_time() const;
  inline void set_latest_update_time(::google::protobuf::uint32 value);
  
  // optional bytes attach_data = 20;
  inline bool has_attach_data() const;
  inline void clear_attach_data();
  static const int kAttachDataFieldNumber = 20;
  inline const ::std::string& attach_data() const;
  inline void set_attach_data(const ::std::string& value);
  inline void set_attach_data(const char* value);
  inline void set_attach_data(const void* value, size_t size);
  inline ::std::string* mutable_attach_data();
  inline ::std::string* release_attach_data();
  
  // @@protoc_insertion_point(class_scope:IM.Buddy.IMAllUserReq)
 private:
  inline void set_has_user_id();
  inline void clear_has_user_id();
  inline void set_has_latest_update_time();
  inline void clear_has_latest_update_time();
  inline void set_has_attach_data();
  inline void clear_has_attach_data();
  
  ::google::protobuf::uint32 user_id_;
  ::google::protobuf::uint32 latest_update_time_;
  ::std::string* attach_data_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];
  
  friend void  protobuf_AddDesc_IM_2eBuddy_2eproto();
  friend void protobuf_AssignDesc_IM_2eBuddy_2eproto();
  friend void protobuf_ShutdownFile_IM_2eBuddy_2eproto();
  
  void InitAsDefaultInstance();
  static IMAllUserReq* default_instance_;
};
// -------------------------------------------------------------------

class IMAllUserRsp : public ::google::protobuf::MessageLite {
 public:
  IMAllUserRsp();
  virtual ~IMAllUserRsp();
  
  IMAllUserRsp(const IMAllUserRsp& from);
  
  inline IMAllUserRsp& operator=(const IMAllUserRsp& from) {
    CopyFrom(from);
    return *this;
  }
  
  static const IMAllUserRsp& default_instance();
  
  void Swap(IMAllUserRsp* other);
  
  // implements Message ----------------------------------------------
  
  IMAllUserRsp* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const IMAllUserRsp& from);
  void MergeFrom(const IMAllUserRsp& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::std::string GetTypeName() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required uint32 user_id = 1;
  inline bool has_user_id() const;
  inline void clear_user_id();
  static const int kUserIdFieldNumber = 1;
  inline ::google::protobuf::uint32 user_id() const;
  inline void set_user_id(::google::protobuf::uint32 value);
  
  // required uint32 latest_update_time = 2;
  inline bool has_latest_update_time() const;
  inline void clear_latest_update_time();
  static const int kLatestUpdateTimeFieldNumber = 2;
  inline ::google::protobuf::uint32 latest_update_time() const;
  inline void set_latest_update_time(::google::protobuf::uint32 value);
  
  // repeated .IM.BaseDefine.UserInfo user_list = 3;
  inline int user_list_size() const;
  inline void clear_user_list();
  static const int kUserListFieldNumber = 3;
  inline const ::IM::BaseDefine::UserInfo& user_list(int index) const;
  inline ::IM::BaseDefine::UserInfo* mutable_user_list(int index);
  inline ::IM::BaseDefine::UserInfo* add_user_list();
  inline const ::google::protobuf::RepeatedPtrField< ::IM::BaseDefine::UserInfo >&
      user_list() const;
  inline ::google::protobuf::RepeatedPtrField< ::IM::BaseDefine::UserInfo >*
      mutable_user_list();
  
  // optional bytes attach_data = 20;
  inline bool has_attach_data() const;
  inline void clear_attach_data();
  static const int kAttachDataFieldNumber = 20;
  inline const ::std::string& attach_data() const;
  inline void set_attach_data(const ::std::string& value);
  inline void set_attach_data(const char* value);
  inline void set_attach_data(const void* value, size_t size);
  inline ::std::string* mutable_attach_data();
  inline ::std::string* release_attach_data();
  
  // @@protoc_insertion_point(class_scope:IM.Buddy.IMAllUserRsp)
 private:
  inline void set_has_user_id();
  inline void clear_has_user_id();
  inline void set_has_latest_update_time();
  inline void clear_has_latest_update_time();
  inline void set_has_attach_data();
  inline void clear_has_attach_data();
  
  ::google::protobuf::uint32 user_id_;
  ::google::protobuf::uint32 latest_update_time_;
  ::google::protobuf::RepeatedPtrField< ::IM::BaseDefine::UserInfo > user_list_;
  ::std::string* attach_data_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];
  
  friend void  protobuf_AddDesc_IM_2eBuddy_2eproto();
  friend void protobuf_AssignDesc_IM_2eBuddy_2eproto();
  friend void protobuf_ShutdownFile_IM_2eBuddy_2eproto();
  
  void InitAsDefaultInstance();
  static IMAllUserRsp* default_instance_;
};
// -------------------------------------------------------------------

class IMUsersStatReq : public ::google::protobuf::MessageLite {
 public:
  IMUsersStatReq();
  virtual ~IMUsersStatReq();
  
  IMUsersStatReq(const IMUsersStatReq& from);
  
  inline IMUsersStatReq& operator=(const IMUsersStatReq& from) {
    CopyFrom(from);
    return *this;
  }
  
  static const IMUsersStatReq& default_instance();
  
  void Swap(IMUsersStatReq* other);
  
  // implements Message ----------------------------------------------
  
  IMUsersStatReq* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const IMUsersStatReq& from);
  void MergeFrom(const IMUsersStatReq& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::std::string GetTypeName() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required uint32 user_id = 1;
  inline bool has_user_id() const;
  inline void clear_user_id();
  static const int kUserIdFieldNumber = 1;
  inline ::google::protobuf::uint32 user_id() const;
  inline void set_user_id(::google::protobuf::uint32 value);
  
  // repeated uint32 user_id_list = 2;
  inline int user_id_list_size() const;
  inline void clear_user_id_list();
  static const int kUserIdListFieldNumber = 2;
  inline ::google::protobuf::uint32 user_id_list(int index) const;
  inline void set_user_id_list(int index, ::google::protobuf::uint32 value);
  inline void add_user_id_list(::google::protobuf::uint32 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
      user_id_list() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
      mutable_user_id_list();
  
  // optional bytes attach_data = 20;
  inline bool has_attach_data() const;
  inline void clear_attach_data();
  static const int kAttachDataFieldNumber = 20;
  inline const ::std::string& attach_data() const;
  inline void set_attach_data(const ::std::string& value);
  inline void set_attach_data(const char* value);
  inline void set_attach_data(const void* value, size_t size);
  inline ::std::string* mutable_attach_data();
  inline ::std::string* release_attach_data();
  
  // @@protoc_insertion_point(class_scope:IM.Buddy.IMUsersStatReq)
 private:
  inline void set_has_user_id();
  inline void clear_has_user_id();
  inline void set_has_attach_data();
  inline void clear_has_attach_data();
  
  ::google::protobuf::RepeatedField< ::google::protobuf::uint32 > user_id_list_;
  ::std::string* attach_data_;
  ::google::protobuf::uint32 user_id_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];
  
  friend void  protobuf_AddDesc_IM_2eBuddy_2eproto();
  friend void protobuf_AssignDesc_IM_2eBuddy_2eproto();
  friend void protobuf_ShutdownFile_IM_2eBuddy_2eproto();
  
  void InitAsDefaultInstance();
  static IMUsersStatReq* default_instance_;
};
// -------------------------------------------------------------------

class IMUsersStatRsp : public ::google::protobuf::MessageLite {
 public:
  IMUsersStatRsp();
  virtual ~IMUsersStatRsp();
  
  IMUsersStatRsp(const IMUsersStatRsp& from);
  
  inline IMUsersStatRsp& operator=(const IMUsersStatRsp& from) {
    CopyFrom(from);
    return *this;
  }
  
  static const IMUsersStatRsp& default_instance();
  
  void Swap(IMUsersStatRsp* other);
  
  // implements Message ----------------------------------------------
  
  IMUsersStatRsp* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const IMUsersStatRsp& from);
  void MergeFrom(const IMUsersStatRsp& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::std::string GetTypeName() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required uint32 user_id = 1;
  inline bool has_user_id() const;
  inline void clear_user_id();
  static const int kUserIdFieldNumber = 1;
  inline ::google::protobuf::uint32 user_id() const;
  inline void set_user_id(::google::protobuf::uint32 value);
  
  // repeated .IM.BaseDefine.UserStat user_stat_list = 2;
  inline int user_stat_list_size() const;
  inline void clear_user_stat_list();
  static const int kUserStatListFieldNumber = 2;
  inline const ::IM::BaseDefine::UserStat& user_stat_list(int index) const;
  inline ::IM::BaseDefine::UserStat* mutable_user_stat_list(int index);
  inline ::IM::BaseDefine::UserStat* add_user_stat_list();
  inline const ::google::protobuf::RepeatedPtrField< ::IM::BaseDefine::UserStat >&
      user_stat_list() const;
  inline ::google::protobuf::RepeatedPtrField< ::IM::BaseDefine::UserStat >*
      mutable_user_stat_list();
  
  // optional bytes attach_data = 20;
  inline bool has_attach_data() const;
  inline void clear_attach_data();
  static const int kAttachDataFieldNumber = 20;
  inline const ::std::string& attach_data() const;
  inline void set_attach_data(const ::std::string& value);
  inline void set_attach_data(const char* value);
  inline void set_attach_data(const void* value, size_t size);
  inline ::std::string* mutable_attach_data();
  inline ::std::string* release_attach_data();
  
  // @@protoc_insertion_point(class_scope:IM.Buddy.IMUsersStatRsp)
 private:
  inline void set_has_user_id();
  inline void clear_has_user_id();
  inline void set_has_attach_data();
  inline void clear_has_attach_data();
  
  ::google::protobuf::RepeatedPtrField< ::IM::BaseDefine::UserStat > user_stat_list_;
  ::std::string* attach_data_;
  ::google::protobuf::uint32 user_id_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];
  
  friend void  protobuf_AddDesc_IM_2eBuddy_2eproto();
  friend void protobuf_AssignDesc_IM_2eBuddy_2eproto();
  friend void protobuf_ShutdownFile_IM_2eBuddy_2eproto();
  
  void InitAsDefaultInstance();
  static IMUsersStatRsp* default_instance_;
};
// -------------------------------------------------------------------

class IMChangeAvatarReq : public ::google::protobuf::MessageLite {
 public:
  IMChangeAvatarReq();
  virtual ~IMChangeAvatarReq();
  
  IMChangeAvatarReq(const IMChangeAvatarReq& from);
  
  inline IMChangeAvatarReq& operator=(const IMChangeAvatarReq& from) {
    CopyFrom(from);
    return *this;
  }
  
  static const IMChangeAvatarReq& default_instance();
  
  void Swap(IMChangeAvatarReq* other);
  
  // implements Message ----------------------------------------------
  
  IMChangeAvatarReq* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const IMChangeAvatarReq& from);
  void MergeFrom(const IMChangeAvatarReq& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::std::string GetTypeName() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required uint32 user_id = 1;
  inline bool has_user_id() const;
  inline void clear_user_id();
  static const int kUserIdFieldNumber = 1;
  inline ::google::protobuf::uint32 user_id() const;
  inline void set_user_id(::google::protobuf::uint32 value);
  
  // required string avatar_url = 2;
  inline bool has_avatar_url() const;
  inline void clear_avatar_url();
  static const int kAvatarUrlFieldNumber = 2;
  inline const ::std::string& avatar_url() const;
  inline void set_avatar_url(const ::std::string& value);
  inline void set_avatar_url(const char* value);
  inline void set_avatar_url(const char* value, size_t size);
  inline ::std::string* mutable_avatar_url();
  inline ::std::string* release_avatar_url();
  
  // optional bytes attach_data = 20;
  inline bool has_attach_data() const;
  inline void clear_attach_data();
  static const int kAttachDataFieldNumber = 20;
  inline const ::std::string& attach_data() const;
  inline void set_attach_data(const ::std::string& value);
  inline void set_attach_data(const char* value);
  inline void set_attach_data(const void* value, size_t size);
  inline ::std::string* mutable_attach_data();
  inline ::std::string* release_attach_data();
  
  // @@protoc_insertion_point(class_scope:IM.Buddy.IMChangeAvatarReq)
 private:
  inline void set_has_user_id();
  inline void clear_has_user_id();
  inline void set_has_avatar_url();
  inline void clear_has_avatar_url();
  inline void set_has_attach_data();
  inline void clear_has_attach_data();
  
  ::std::string* avatar_url_;
  ::std::string* attach_data_;
  ::google::protobuf::uint32 user_id_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];
  
  friend void  protobuf_AddDesc_IM_2eBuddy_2eproto();
  friend void protobuf_AssignDesc_IM_2eBuddy_2eproto();
  friend void protobuf_ShutdownFile_IM_2eBuddy_2eproto();
  
  void InitAsDefaultInstance();
  static IMChangeAvatarReq* default_instance_;
};
// -------------------------------------------------------------------

class IMChangeAvatarRsp : public ::google::protobuf::MessageLite {
 public:
  IMChangeAvatarRsp();
  virtual ~IMChangeAvatarRsp();
  
  IMChangeAvatarRsp(const IMChangeAvatarRsp& from);
  
  inline IMChangeAvatarRsp& operator=(const IMChangeAvatarRsp& from) {
    CopyFrom(from);
    return *this;
  }
  
  static const IMChangeAvatarRsp& default_instance();
  
  void Swap(IMChangeAvatarRsp* other);
  
  // implements Message ----------------------------------------------
  
  IMChangeAvatarRsp* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const IMChangeAvatarRsp& from);
  void MergeFrom(const IMChangeAvatarRsp& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::std::string GetTypeName() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required uint32 user_id = 1;
  inline bool has_user_id() const;
  inline void clear_user_id();
  static const int kUserIdFieldNumber = 1;
  inline ::google::protobuf::uint32 user_id() const;
  inline void set_user_id(::google::protobuf::uint32 value);
  
  // required uint32 result_code = 2;
  inline bool has_result_code() const;
  inline void clear_result_code();
  static const int kResultCodeFieldNumber = 2;
  inline ::google::protobuf::uint32 result_code() const;
  inline void set_result_code(::google::protobuf::uint32 value);
  
  // optional bytes attach_data = 20;
  inline bool has_attach_data() const;
  inline void clear_attach_data();
  static const int kAttachDataFieldNumber = 20;
  inline const ::std::string& attach_data() const;
  inline void set_attach_data(const ::std::string& value);
  inline void set_attach_data(const char* value);
  inline void set_attach_data(const void* value, size_t size);
  inline ::std::string* mutable_attach_data();
  inline ::std::string* release_attach_data();
  
  // @@protoc_insertion_point(class_scope:IM.Buddy.IMChangeAvatarRsp)
 private:
  inline void set_has_user_id();
  inline void clear_has_user_id();
  inline void set_has_result_code();
  inline void clear_has_result_code();
  inline void set_has_attach_data();
  inline void clear_has_attach_data();
  
  ::google::protobuf::uint32 user_id_;
  ::google::protobuf::uint32 result_code_;
  ::std::string* attach_data_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];
  
  friend void  protobuf_AddDesc_IM_2eBuddy_2eproto();
  friend void protobuf_AssignDesc_IM_2eBuddy_2eproto();
  friend void protobuf_ShutdownFile_IM_2eBuddy_2eproto();
  
  void InitAsDefaultInstance();
  static IMChangeAvatarRsp* default_instance_;
};
// -------------------------------------------------------------------

class IMPCLoginStatusNotify : public ::google::protobuf::MessageLite {
 public:
  IMPCLoginStatusNotify();
  virtual ~IMPCLoginStatusNotify();
  
  IMPCLoginStatusNotify(const IMPCLoginStatusNotify& from);
  
  inline IMPCLoginStatusNotify& operator=(const IMPCLoginStatusNotify& from) {
    CopyFrom(from);
    return *this;
  }
  
  static const IMPCLoginStatusNotify& default_instance();
  
  void Swap(IMPCLoginStatusNotify* other);
  
  // implements Message ----------------------------------------------
  
  IMPCLoginStatusNotify* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const IMPCLoginStatusNotify& from);
  void MergeFrom(const IMPCLoginStatusNotify& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::std::string GetTypeName() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required uint32 user_id = 1;
  inline bool has_user_id() const;
  inline void clear_user_id();
  static const int kUserIdFieldNumber = 1;
  inline ::google::protobuf::uint32 user_id() const;
  inline void set_user_id(::google::protobuf::uint32 value);
  
  // required .IM.BaseDefine.UserStatType login_stat = 2;
  inline bool has_login_stat() const;
  inline void clear_login_stat();
  static const int kLoginStatFieldNumber = 2;
  inline IM::BaseDefine::UserStatType login_stat() const;
  inline void set_login_stat(IM::BaseDefine::UserStatType value);
  
  // @@protoc_insertion_point(class_scope:IM.Buddy.IMPCLoginStatusNotify)
 private:
  inline void set_has_user_id();
  inline void clear_has_user_id();
  inline void set_has_login_stat();
  inline void clear_has_login_stat();
  
  ::google::protobuf::uint32 user_id_;
  int login_stat_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];
  
  friend void  protobuf_AddDesc_IM_2eBuddy_2eproto();
  friend void protobuf_AssignDesc_IM_2eBuddy_2eproto();
  friend void protobuf_ShutdownFile_IM_2eBuddy_2eproto();
  
  void InitAsDefaultInstance();
  static IMPCLoginStatusNotify* default_instance_;
};
// -------------------------------------------------------------------

class IMRemoveSessionNotify : public ::google::protobuf::MessageLite {
 public:
  IMRemoveSessionNotify();
  virtual ~IMRemoveSessionNotify();
  
  IMRemoveSessionNotify(const IMRemoveSessionNotify& from);
  
  inline IMRemoveSessionNotify& operator=(const IMRemoveSessionNotify& from) {
    CopyFrom(from);
    return *this;
  }
  
  static const IMRemoveSessionNotify& default_instance();
  
  void Swap(IMRemoveSessionNotify* other);
  
  // implements Message ----------------------------------------------
  
  IMRemoveSessionNotify* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const IMRemoveSessionNotify& from);
  void MergeFrom(const IMRemoveSessionNotify& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::std::string GetTypeName() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required uint32 user_id = 1;
  inline bool has_user_id() const;
  inline void clear_user_id();
  static const int kUserIdFieldNumber = 1;
  inline ::google::protobuf::uint32 user_id() const;
  inline void set_user_id(::google::protobuf::uint32 value);
  
  // required .IM.BaseDefine.SessionType session_type = 2;
  inline bool has_session_type() const;
  inline void clear_session_type();
  static const int kSessionTypeFieldNumber = 2;
  inline IM::BaseDefine::SessionType session_type() const;
  inline void set_session_type(IM::BaseDefine::SessionType value);
  
  // required uint32 session_id = 3;
  inline bool has_session_id() const;
  inline void clear_session_id();
  static const int kSessionIdFieldNumber = 3;
  inline ::google::protobuf::uint32 session_id() const;
  inline void set_session_id(::google::protobuf::uint32 value);
  
  // @@protoc_insertion_point(class_scope:IM.Buddy.IMRemoveSessionNotify)
 private:
  inline void set_has_user_id();
  inline void clear_has_user_id();
  inline void set_has_session_type();
  inline void clear_has_session_type();
  inline void set_has_session_id();
  inline void clear_has_session_id();
  
  ::google::protobuf::uint32 user_id_;
  int session_type_;
  ::google::protobuf::uint32 session_id_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];
  
  friend void  protobuf_AddDesc_IM_2eBuddy_2eproto();
  friend void protobuf_AssignDesc_IM_2eBuddy_2eproto();
  friend void protobuf_ShutdownFile_IM_2eBuddy_2eproto();
  
  void InitAsDefaultInstance();
  static IMRemoveSessionNotify* default_instance_;
};
// -------------------------------------------------------------------

class IMDepartmentReq : public ::google::protobuf::MessageLite {
 public:
  IMDepartmentReq();
  virtual ~IMDepartmentReq();
  
  IMDepartmentReq(const IMDepartmentReq& from);
  
  inline IMDepartmentReq& operator=(const IMDepartmentReq& from) {
    CopyFrom(from);
    return *this;
  }
  
  static const IMDepartmentReq& default_instance();
  
  void Swap(IMDepartmentReq* other);
  
  // implements Message ----------------------------------------------
  
  IMDepartmentReq* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const IMDepartmentReq& from);
  void MergeFrom(const IMDepartmentReq& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::std::string GetTypeName() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required uint32 user_id = 1;
  inline bool has_user_id() const;
  inline void clear_user_id();
  static const int kUserIdFieldNumber = 1;
  inline ::google::protobuf::uint32 user_id() const;
  inline void set_user_id(::google::protobuf::uint32 value);
  
  // required uint32 latest_update_time = 2;
  inline bool has_latest_update_time() const;
  inline void clear_latest_update_time();
  static const int kLatestUpdateTimeFieldNumber = 2;
  inline ::google::protobuf::uint32 latest_update_time() const;
  inline void set_latest_update_time(::google::protobuf::uint32 value);
  
  // optional bytes attach_data = 20;
  inline bool has_attach_data() const;
  inline void clear_attach_data();
  static const int kAttachDataFieldNumber = 20;
  inline const ::std::string& attach_data() const;
  inline void set_attach_data(const ::std::string& value);
  inline void set_attach_data(const char* value);
  inline void set_attach_data(const void* value, size_t size);
  inline ::std::string* mutable_attach_data();
  inline ::std::string* release_attach_data();
  
  // @@protoc_insertion_point(class_scope:IM.Buddy.IMDepartmentReq)
 private:
  inline void set_has_user_id();
  inline void clear_has_user_id();
  inline void set_has_latest_update_time();
  inline void clear_has_latest_update_time();
  inline void set_has_attach_data();
  inline void clear_has_attach_data();
  
  ::google::protobuf::uint32 user_id_;
  ::google::protobuf::uint32 latest_update_time_;
  ::std::string* attach_data_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];
  
  friend void  protobuf_AddDesc_IM_2eBuddy_2eproto();
  friend void protobuf_AssignDesc_IM_2eBuddy_2eproto();
  friend void protobuf_ShutdownFile_IM_2eBuddy_2eproto();
  
  void InitAsDefaultInstance();
  static IMDepartmentReq* default_instance_;
};
// -------------------------------------------------------------------

class IMDepartmentRsp : public ::google::protobuf::MessageLite {
 public:
  IMDepartmentRsp();
  virtual ~IMDepartmentRsp();
  
  IMDepartmentRsp(const IMDepartmentRsp& from);
  
  inline IMDepartmentRsp& operator=(const IMDepartmentRsp& from) {
    CopyFrom(from);
    return *this;
  }
  
  static const IMDepartmentRsp& default_instance();
  
  void Swap(IMDepartmentRsp* other);
  
  // implements Message ----------------------------------------------
  
  IMDepartmentRsp* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const IMDepartmentRsp& from);
  void MergeFrom(const IMDepartmentRsp& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::std::string GetTypeName() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required uint32 user_id = 1;
  inline bool has_user_id() const;
  inline void clear_user_id();
  static const int kUserIdFieldNumber = 1;
  inline ::google::protobuf::uint32 user_id() const;
  inline void set_user_id(::google::protobuf::uint32 value);
  
  // required uint32 latest_update_time = 2;
  inline bool has_latest_update_time() const;
  inline void clear_latest_update_time();
  static const int kLatestUpdateTimeFieldNumber = 2;
  inline ::google::protobuf::uint32 latest_update_time() const;
  inline void set_latest_update_time(::google::protobuf::uint32 value);
  
  // repeated .IM.BaseDefine.DepartInfo dept_list = 3;
  inline int dept_list_size() const;
  inline void clear_dept_list();
  static const int kDeptListFieldNumber = 3;
  inline const ::IM::BaseDefine::DepartInfo& dept_list(int index) const;
  inline ::IM::BaseDefine::DepartInfo* mutable_dept_list(int index);
  inline ::IM::BaseDefine::DepartInfo* add_dept_list();
  inline const ::google::protobuf::RepeatedPtrField< ::IM::BaseDefine::DepartInfo >&
      dept_list() const;
  inline ::google::protobuf::RepeatedPtrField< ::IM::BaseDefine::DepartInfo >*
      mutable_dept_list();
  
  // optional bytes attach_data = 20;
  inline bool has_attach_data() const;
  inline void clear_attach_data();
  static const int kAttachDataFieldNumber = 20;
  inline const ::std::string& attach_data() const;
  inline void set_attach_data(const ::std::string& value);
  inline void set_attach_data(const char* value);
  inline void set_attach_data(const void* value, size_t size);
  inline ::std::string* mutable_attach_data();
  inline ::std::string* release_attach_data();
  
  // @@protoc_insertion_point(class_scope:IM.Buddy.IMDepartmentRsp)
 private:
  inline void set_has_user_id();
  inline void clear_has_user_id();
  inline void set_has_latest_update_time();
  inline void clear_has_latest_update_time();
  inline void set_has_attach_data();
  inline void clear_has_attach_data();
  
  ::google::protobuf::uint32 user_id_;
  ::google::protobuf::uint32 latest_update_time_;
  ::google::protobuf::RepeatedPtrField< ::IM::BaseDefine::DepartInfo > dept_list_;
  ::std::string* attach_data_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];
  
  friend void  protobuf_AddDesc_IM_2eBuddy_2eproto();
  friend void protobuf_AssignDesc_IM_2eBuddy_2eproto();
  friend void protobuf_ShutdownFile_IM_2eBuddy_2eproto();
  
  void InitAsDefaultInstance();
  static IMDepartmentRsp* default_instance_;
};
// ===================================================================


// ===================================================================

// IMRecentContactSessionReq

// required uint32 user_id = 1;
inline bool IMRecentContactSessionReq::has_user_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void IMRecentContactSessionReq::set_has_user_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void IMRecentContactSessionReq::clear_has_user_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void IMRecentContactSessionReq::clear_user_id() {
  user_id_ = 0u;
  clear_has_user_id();
}
inline ::google::protobuf::uint32 IMRecentContactSessionReq::user_id() const {
  return user_id_;
}
inline void IMRecentContactSessionReq::set_user_id(::google::protobuf::uint32 value) {
  set_has_user_id();
  user_id_ = value;
}

// required uint32 latest_update_time = 2;
inline bool IMRecentContactSessionReq::has_latest_update_time() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void IMRecentContactSessionReq::set_has_latest_update_time() {
  _has_bits_[0] |= 0x00000002u;
}
inline void IMRecentContactSessionReq::clear_has_latest_update_time() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void IMRecentContactSessionReq::clear_latest_update_time() {
  latest_update_time_ = 0u;
  clear_has_latest_update_time();
}
inline ::google::protobuf::uint32 IMRecentContactSessionReq::latest_update_time() const {
  return latest_update_time_;
}
inline void IMRecentContactSessionReq::set_latest_update_time(::google::protobuf::uint32 value) {
  set_has_latest_update_time();
  latest_update_time_ = value;
}

// optional bytes attach_data = 20;
inline bool IMRecentContactSessionReq::has_attach_data() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void IMRecentContactSessionReq::set_has_attach_data() {
  _has_bits_[0] |= 0x00000004u;
}
inline void IMRecentContactSessionReq::clear_has_attach_data() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void IMRecentContactSessionReq::clear_attach_data() {
  if (attach_data_ != &::google::protobuf::internal::kEmptyString) {
    attach_data_->clear();
  }
  clear_has_attach_data();
}
inline const ::std::string& IMRecentContactSessionReq::attach_data() const {
  return *attach_data_;
}
inline void IMRecentContactSessionReq::set_attach_data(const ::std::string& value) {
  set_has_attach_data();
  if (attach_data_ == &::google::protobuf::internal::kEmptyString) {
    attach_data_ = new ::std::string;
  }
  attach_data_->assign(value);
}
inline void IMRecentContactSessionReq::set_attach_data(const char* value) {
  set_has_attach_data();
  if (attach_data_ == &::google::protobuf::internal::kEmptyString) {
    attach_data_ = new ::std::string;
  }
  attach_data_->assign(value);
}
inline void IMRecentContactSessionReq::set_attach_data(const void* value, size_t size) {
  set_has_attach_data();
  if (attach_data_ == &::google::protobuf::internal::kEmptyString) {
    attach_data_ = new ::std::string;
  }
  attach_data_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* IMRecentContactSessionReq::mutable_attach_data() {
  set_has_attach_data();
  if (attach_data_ == &::google::protobuf::internal::kEmptyString) {
    attach_data_ = new ::std::string;
  }
  return attach_data_;
}
inline ::std::string* IMRecentContactSessionReq::release_attach_data() {
  clear_has_attach_data();
  if (attach_data_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = attach_data_;
    attach_data_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// -------------------------------------------------------------------

// IMRecentContactSessionRsp

// required uint32 user_id = 1;
inline bool IMRecentContactSessionRsp::has_user_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void IMRecentContactSessionRsp::set_has_user_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void IMRecentContactSessionRsp::clear_has_user_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void IMRecentContactSessionRsp::clear_user_id() {
  user_id_ = 0u;
  clear_has_user_id();
}
inline ::google::protobuf::uint32 IMRecentContactSessionRsp::user_id() const {
  return user_id_;
}
inline void IMRecentContactSessionRsp::set_user_id(::google::protobuf::uint32 value) {
  set_has_user_id();
  user_id_ = value;
}

// repeated .IM.BaseDefine.ContactSessionInfo contact_session_list = 2;
inline int IMRecentContactSessionRsp::contact_session_list_size() const {
  return contact_session_list_.size();
}
inline void IMRecentContactSessionRsp::clear_contact_session_list() {
  contact_session_list_.Clear();
}
inline const ::IM::BaseDefine::ContactSessionInfo& IMRecentContactSessionRsp::contact_session_list(int index) const {
  return contact_session_list_.Get(index);
}
inline ::IM::BaseDefine::ContactSessionInfo* IMRecentContactSessionRsp::mutable_contact_session_list(int index) {
  return contact_session_list_.Mutable(index);
}
inline ::IM::BaseDefine::ContactSessionInfo* IMRecentContactSessionRsp::add_contact_session_list() {
  return contact_session_list_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::IM::BaseDefine::ContactSessionInfo >&
IMRecentContactSessionRsp::contact_session_list() const {
  return contact_session_list_;
}
inline ::google::protobuf::RepeatedPtrField< ::IM::BaseDefine::ContactSessionInfo >*
IMRecentContactSessionRsp::mutable_contact_session_list() {
  return &contact_session_list_;
}

// optional bytes attach_data = 20;
inline bool IMRecentContactSessionRsp::has_attach_data() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void IMRecentContactSessionRsp::set_has_attach_data() {
  _has_bits_[0] |= 0x00000004u;
}
inline void IMRecentContactSessionRsp::clear_has_attach_data() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void IMRecentContactSessionRsp::clear_attach_data() {
  if (attach_data_ != &::google::protobuf::internal::kEmptyString) {
    attach_data_->clear();
  }
  clear_has_attach_data();
}
inline const ::std::string& IMRecentContactSessionRsp::attach_data() const {
  return *attach_data_;
}
inline void IMRecentContactSessionRsp::set_attach_data(const ::std::string& value) {
  set_has_attach_data();
  if (attach_data_ == &::google::protobuf::internal::kEmptyString) {
    attach_data_ = new ::std::string;
  }
  attach_data_->assign(value);
}
inline void IMRecentContactSessionRsp::set_attach_data(const char* value) {
  set_has_attach_data();
  if (attach_data_ == &::google::protobuf::internal::kEmptyString) {
    attach_data_ = new ::std::string;
  }
  attach_data_->assign(value);
}
inline void IMRecentContactSessionRsp::set_attach_data(const void* value, size_t size) {
  set_has_attach_data();
  if (attach_data_ == &::google::protobuf::internal::kEmptyString) {
    attach_data_ = new ::std::string;
  }
  attach_data_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* IMRecentContactSessionRsp::mutable_attach_data() {
  set_has_attach_data();
  if (attach_data_ == &::google::protobuf::internal::kEmptyString) {
    attach_data_ = new ::std::string;
  }
  return attach_data_;
}
inline ::std::string* IMRecentContactSessionRsp::release_attach_data() {
  clear_has_attach_data();
  if (attach_data_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = attach_data_;
    attach_data_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// -------------------------------------------------------------------

// IMUserStatNotify

// required .IM.BaseDefine.UserStat user_stat = 1;
inline bool IMUserStatNotify::has_user_stat() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void IMUserStatNotify::set_has_user_stat() {
  _has_bits_[0] |= 0x00000001u;
}
inline void IMUserStatNotify::clear_has_user_stat() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void IMUserStatNotify::clear_user_stat() {
  if (user_stat_ != NULL) user_stat_->::IM::BaseDefine::UserStat::Clear();
  clear_has_user_stat();
}
inline const ::IM::BaseDefine::UserStat& IMUserStatNotify::user_stat() const {
  return user_stat_ != NULL ? *user_stat_ : *default_instance_->user_stat_;
}
inline ::IM::BaseDefine::UserStat* IMUserStatNotify::mutable_user_stat() {
  set_has_user_stat();
  if (user_stat_ == NULL) user_stat_ = new ::IM::BaseDefine::UserStat;
  return user_stat_;
}
inline ::IM::BaseDefine::UserStat* IMUserStatNotify::release_user_stat() {
  clear_has_user_stat();
  ::IM::BaseDefine::UserStat* temp = user_stat_;
  user_stat_ = NULL;
  return temp;
}

// -------------------------------------------------------------------

// IMUsersInfoReq

// required uint32 user_id = 1;
inline bool IMUsersInfoReq::has_user_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void IMUsersInfoReq::set_has_user_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void IMUsersInfoReq::clear_has_user_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void IMUsersInfoReq::clear_user_id() {
  user_id_ = 0u;
  clear_has_user_id();
}
inline ::google::protobuf::uint32 IMUsersInfoReq::user_id() const {
  return user_id_;
}
inline void IMUsersInfoReq::set_user_id(::google::protobuf::uint32 value) {
  set_has_user_id();
  user_id_ = value;
}

// repeated uint32 user_id_list = 2;
inline int IMUsersInfoReq::user_id_list_size() const {
  return user_id_list_.size();
}
inline void IMUsersInfoReq::clear_user_id_list() {
  user_id_list_.Clear();
}
inline ::google::protobuf::uint32 IMUsersInfoReq::user_id_list(int index) const {
  return user_id_list_.Get(index);
}
inline void IMUsersInfoReq::set_user_id_list(int index, ::google::protobuf::uint32 value) {
  user_id_list_.Set(index, value);
}
inline void IMUsersInfoReq::add_user_id_list(::google::protobuf::uint32 value) {
  user_id_list_.Add(value);
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
IMUsersInfoReq::user_id_list() const {
  return user_id_list_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
IMUsersInfoReq::mutable_user_id_list() {
  return &user_id_list_;
}

// optional bytes attach_data = 20;
inline bool IMUsersInfoReq::has_attach_data() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void IMUsersInfoReq::set_has_attach_data() {
  _has_bits_[0] |= 0x00000004u;
}
inline void IMUsersInfoReq::clear_has_attach_data() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void IMUsersInfoReq::clear_attach_data() {
  if (attach_data_ != &::google::protobuf::internal::kEmptyString) {
    attach_data_->clear();
  }
  clear_has_attach_data();
}
inline const ::std::string& IMUsersInfoReq::attach_data() const {
  return *attach_data_;
}
inline void IMUsersInfoReq::set_attach_data(const ::std::string& value) {
  set_has_attach_data();
  if (attach_data_ == &::google::protobuf::internal::kEmptyString) {
    attach_data_ = new ::std::string;
  }
  attach_data_->assign(value);
}
inline void IMUsersInfoReq::set_attach_data(const char* value) {
  set_has_attach_data();
  if (attach_data_ == &::google::protobuf::internal::kEmptyString) {
    attach_data_ = new ::std::string;
  }
  attach_data_->assign(value);
}
inline void IMUsersInfoReq::set_attach_data(const void* value, size_t size) {
  set_has_attach_data();
  if (attach_data_ == &::google::protobuf::internal::kEmptyString) {
    attach_data_ = new ::std::string;
  }
  attach_data_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* IMUsersInfoReq::mutable_attach_data() {
  set_has_attach_data();
  if (attach_data_ == &::google::protobuf::internal::kEmptyString) {
    attach_data_ = new ::std::string;
  }
  return attach_data_;
}
inline ::std::string* IMUsersInfoReq::release_attach_data() {
  clear_has_attach_data();
  if (attach_data_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = attach_data_;
    attach_data_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// -------------------------------------------------------------------

// IMUsersInfoRsp

// required uint32 user_id = 1;
inline bool IMUsersInfoRsp::has_user_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void IMUsersInfoRsp::set_has_user_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void IMUsersInfoRsp::clear_has_user_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void IMUsersInfoRsp::clear_user_id() {
  user_id_ = 0u;
  clear_has_user_id();
}
inline ::google::protobuf::uint32 IMUsersInfoRsp::user_id() const {
  return user_id_;
}
inline void IMUsersInfoRsp::set_user_id(::google::protobuf::uint32 value) {
  set_has_user_id();
  user_id_ = value;
}

// repeated .IM.BaseDefine.UserInfo user_info_list = 2;
inline int IMUsersInfoRsp::user_info_list_size() const {
  return user_info_list_.size();
}
inline void IMUsersInfoRsp::clear_user_info_list() {
  user_info_list_.Clear();
}
inline const ::IM::BaseDefine::UserInfo& IMUsersInfoRsp::user_info_list(int index) const {
  return user_info_list_.Get(index);
}
inline ::IM::BaseDefine::UserInfo* IMUsersInfoRsp::mutable_user_info_list(int index) {
  return user_info_list_.Mutable(index);
}
inline ::IM::BaseDefine::UserInfo* IMUsersInfoRsp::add_user_info_list() {
  return user_info_list_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::IM::BaseDefine::UserInfo >&
IMUsersInfoRsp::user_info_list() const {
  return user_info_list_;
}
inline ::google::protobuf::RepeatedPtrField< ::IM::BaseDefine::UserInfo >*
IMUsersInfoRsp::mutable_user_info_list() {
  return &user_info_list_;
}

// optional bytes attach_data = 20;
inline bool IMUsersInfoRsp::has_attach_data() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void IMUsersInfoRsp::set_has_attach_data() {
  _has_bits_[0] |= 0x00000004u;
}
inline void IMUsersInfoRsp::clear_has_attach_data() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void IMUsersInfoRsp::clear_attach_data() {
  if (attach_data_ != &::google::protobuf::internal::kEmptyString) {
    attach_data_->clear();
  }
  clear_has_attach_data();
}
inline const ::std::string& IMUsersInfoRsp::attach_data() const {
  return *attach_data_;
}
inline void IMUsersInfoRsp::set_attach_data(const ::std::string& value) {
  set_has_attach_data();
  if (attach_data_ == &::google::protobuf::internal::kEmptyString) {
    attach_data_ = new ::std::string;
  }
  attach_data_->assign(value);
}
inline void IMUsersInfoRsp::set_attach_data(const char* value) {
  set_has_attach_data();
  if (attach_data_ == &::google::protobuf::internal::kEmptyString) {
    attach_data_ = new ::std::string;
  }
  attach_data_->assign(value);
}
inline void IMUsersInfoRsp::set_attach_data(const void* value, size_t size) {
  set_has_attach_data();
  if (attach_data_ == &::google::protobuf::internal::kEmptyString) {
    attach_data_ = new ::std::string;
  }
  attach_data_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* IMUsersInfoRsp::mutable_attach_data() {
  set_has_attach_data();
  if (attach_data_ == &::google::protobuf::internal::kEmptyString) {
    attach_data_ = new ::std::string;
  }
  return attach_data_;
}
inline ::std::string* IMUsersInfoRsp::release_attach_data() {
  clear_has_attach_data();
  if (attach_data_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = attach_data_;
    attach_data_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// -------------------------------------------------------------------

// IMRemoveSessionReq

// required uint32 user_id = 1;
inline bool IMRemoveSessionReq::has_user_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void IMRemoveSessionReq::set_has_user_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void IMRemoveSessionReq::clear_has_user_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void IMRemoveSessionReq::clear_user_id() {
  user_id_ = 0u;
  clear_has_user_id();
}
inline ::google::protobuf::uint32 IMRemoveSessionReq::user_id() const {
  return user_id_;
}
inline void IMRemoveSessionReq::set_user_id(::google::protobuf::uint32 value) {
  set_has_user_id();
  user_id_ = value;
}

// required .IM.BaseDefine.SessionType session_type = 2;
inline bool IMRemoveSessionReq::has_session_type() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void IMRemoveSessionReq::set_has_session_type() {
  _has_bits_[0] |= 0x00000002u;
}
inline void IMRemoveSessionReq::clear_has_session_type() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void IMRemoveSessionReq::clear_session_type() {
  session_type_ = 1;
  clear_has_session_type();
}
inline IM::BaseDefine::SessionType IMRemoveSessionReq::session_type() const {
  return static_cast< IM::BaseDefine::SessionType >(session_type_);
}
inline void IMRemoveSessionReq::set_session_type(IM::BaseDefine::SessionType value) {
  GOOGLE_DCHECK(IM::BaseDefine::SessionType_IsValid(value));
  set_has_session_type();
  session_type_ = value;
}

// required uint32 session_id = 3;
inline bool IMRemoveSessionReq::has_session_id() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void IMRemoveSessionReq::set_has_session_id() {
  _has_bits_[0] |= 0x00000004u;
}
inline void IMRemoveSessionReq::clear_has_session_id() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void IMRemoveSessionReq::clear_session_id() {
  session_id_ = 0u;
  clear_has_session_id();
}
inline ::google::protobuf::uint32 IMRemoveSessionReq::session_id() const {
  return session_id_;
}
inline void IMRemoveSessionReq::set_session_id(::google::protobuf::uint32 value) {
  set_has_session_id();
  session_id_ = value;
}

// optional bytes attach_data = 20;
inline bool IMRemoveSessionReq::has_attach_data() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void IMRemoveSessionReq::set_has_attach_data() {
  _has_bits_[0] |= 0x00000008u;
}
inline void IMRemoveSessionReq::clear_has_attach_data() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void IMRemoveSessionReq::clear_attach_data() {
  if (attach_data_ != &::google::protobuf::internal::kEmptyString) {
    attach_data_->clear();
  }
  clear_has_attach_data();
}
inline const ::std::string& IMRemoveSessionReq::attach_data() const {
  return *attach_data_;
}
inline void IMRemoveSessionReq::set_attach_data(const ::std::string& value) {
  set_has_attach_data();
  if (attach_data_ == &::google::protobuf::internal::kEmptyString) {
    attach_data_ = new ::std::string;
  }
  attach_data_->assign(value);
}
inline void IMRemoveSessionReq::set_attach_data(const char* value) {
  set_has_attach_data();
  if (attach_data_ == &::google::protobuf::internal::kEmptyString) {
    attach_data_ = new ::std::string;
  }
  attach_data_->assign(value);
}
inline void IMRemoveSessionReq::set_attach_data(const void* value, size_t size) {
  set_has_attach_data();
  if (attach_data_ == &::google::protobuf::internal::kEmptyString) {
    attach_data_ = new ::std::string;
  }
  attach_data_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* IMRemoveSessionReq::mutable_attach_data() {
  set_has_attach_data();
  if (attach_data_ == &::google::protobuf::internal::kEmptyString) {
    attach_data_ = new ::std::string;
  }
  return attach_data_;
}
inline ::std::string* IMRemoveSessionReq::release_attach_data() {
  clear_has_attach_data();
  if (attach_data_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = attach_data_;
    attach_data_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// -------------------------------------------------------------------

// IMRemoveSessionRsp

// required uint32 user_id = 1;
inline bool IMRemoveSessionRsp::has_user_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void IMRemoveSessionRsp::set_has_user_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void IMRemoveSessionRsp::clear_has_user_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void IMRemoveSessionRsp::clear_user_id() {
  user_id_ = 0u;
  clear_has_user_id();
}
inline ::google::protobuf::uint32 IMRemoveSessionRsp::user_id() const {
  return user_id_;
}
inline void IMRemoveSessionRsp::set_user_id(::google::protobuf::uint32 value) {
  set_has_user_id();
  user_id_ = value;
}

// required uint32 result_code = 2;
inline bool IMRemoveSessionRsp::has_result_code() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void IMRemoveSessionRsp::set_has_result_code() {
  _has_bits_[0] |= 0x00000002u;
}
inline void IMRemoveSessionRsp::clear_has_result_code() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void IMRemoveSessionRsp::clear_result_code() {
  result_code_ = 0u;
  clear_has_result_code();
}
inline ::google::protobuf::uint32 IMRemoveSessionRsp::result_code() const {
  return result_code_;
}
inline void IMRemoveSessionRsp::set_result_code(::google::protobuf::uint32 value) {
  set_has_result_code();
  result_code_ = value;
}

// required .IM.BaseDefine.SessionType session_type = 3;
inline bool IMRemoveSessionRsp::has_session_type() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void IMRemoveSessionRsp::set_has_session_type() {
  _has_bits_[0] |= 0x00000004u;
}
inline void IMRemoveSessionRsp::clear_has_session_type() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void IMRemoveSessionRsp::clear_session_type() {
  session_type_ = 1;
  clear_has_session_type();
}
inline IM::BaseDefine::SessionType IMRemoveSessionRsp::session_type() const {
  return static_cast< IM::BaseDefine::SessionType >(session_type_);
}
inline void IMRemoveSessionRsp::set_session_type(IM::BaseDefine::SessionType value) {
  GOOGLE_DCHECK(IM::BaseDefine::SessionType_IsValid(value));
  set_has_session_type();
  session_type_ = value;
}

// required uint32 session_id = 4;
inline bool IMRemoveSessionRsp::has_session_id() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void IMRemoveSessionRsp::set_has_session_id() {
  _has_bits_[0] |= 0x00000008u;
}
inline void IMRemoveSessionRsp::clear_has_session_id() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void IMRemoveSessionRsp::clear_session_id() {
  session_id_ = 0u;
  clear_has_session_id();
}
inline ::google::protobuf::uint32 IMRemoveSessionRsp::session_id() const {
  return session_id_;
}
inline void IMRemoveSessionRsp::set_session_id(::google::protobuf::uint32 value) {
  set_has_session_id();
  session_id_ = value;
}

// optional bytes attach_data = 20;
inline bool IMRemoveSessionRsp::has_attach_data() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void IMRemoveSessionRsp::set_has_attach_data() {
  _has_bits_[0] |= 0x00000010u;
}
inline void IMRemoveSessionRsp::clear_has_attach_data() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void IMRemoveSessionRsp::clear_attach_data() {
  if (attach_data_ != &::google::protobuf::internal::kEmptyString) {
    attach_data_->clear();
  }
  clear_has_attach_data();
}
inline const ::std::string& IMRemoveSessionRsp::attach_data() const {
  return *attach_data_;
}
inline void IMRemoveSessionRsp::set_attach_data(const ::std::string& value) {
  set_has_attach_data();
  if (attach_data_ == &::google::protobuf::internal::kEmptyString) {
    attach_data_ = new ::std::string;
  }
  attach_data_->assign(value);
}
inline void IMRemoveSessionRsp::set_attach_data(const char* value) {
  set_has_attach_data();
  if (attach_data_ == &::google::protobuf::internal::kEmptyString) {
    attach_data_ = new ::std::string;
  }
  attach_data_->assign(value);
}
inline void IMRemoveSessionRsp::set_attach_data(const void* value, size_t size) {
  set_has_attach_data();
  if (attach_data_ == &::google::protobuf::internal::kEmptyString) {
    attach_data_ = new ::std::string;
  }
  attach_data_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* IMRemoveSessionRsp::mutable_attach_data() {
  set_has_attach_data();
  if (attach_data_ == &::google::protobuf::internal::kEmptyString) {
    attach_data_ = new ::std::string;
  }
  return attach_data_;
}
inline ::std::string* IMRemoveSessionRsp::release_attach_data() {
  clear_has_attach_data();
  if (attach_data_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = attach_data_;
    attach_data_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// -------------------------------------------------------------------

// IMAllUserReq

// required uint32 user_id = 1;
inline bool IMAllUserReq::has_user_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void IMAllUserReq::set_has_user_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void IMAllUserReq::clear_has_user_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void IMAllUserReq::clear_user_id() {
  user_id_ = 0u;
  clear_has_user_id();
}
inline ::google::protobuf::uint32 IMAllUserReq::user_id() const {
  return user_id_;
}
inline void IMAllUserReq::set_user_id(::google::protobuf::uint32 value) {
  set_has_user_id();
  user_id_ = value;
}

// required uint32 latest_update_time = 2;
inline bool IMAllUserReq::has_latest_update_time() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void IMAllUserReq::set_has_latest_update_time() {
  _has_bits_[0] |= 0x00000002u;
}
inline void IMAllUserReq::clear_has_latest_update_time() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void IMAllUserReq::clear_latest_update_time() {
  latest_update_time_ = 0u;
  clear_has_latest_update_time();
}
inline ::google::protobuf::uint32 IMAllUserReq::latest_update_time() const {
  return latest_update_time_;
}
inline void IMAllUserReq::set_latest_update_time(::google::protobuf::uint32 value) {
  set_has_latest_update_time();
  latest_update_time_ = value;
}

// optional bytes attach_data = 20;
inline bool IMAllUserReq::has_attach_data() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void IMAllUserReq::set_has_attach_data() {
  _has_bits_[0] |= 0x00000004u;
}
inline void IMAllUserReq::clear_has_attach_data() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void IMAllUserReq::clear_attach_data() {
  if (attach_data_ != &::google::protobuf::internal::kEmptyString) {
    attach_data_->clear();
  }
  clear_has_attach_data();
}
inline const ::std::string& IMAllUserReq::attach_data() const {
  return *attach_data_;
}
inline void IMAllUserReq::set_attach_data(const ::std::string& value) {
  set_has_attach_data();
  if (attach_data_ == &::google::protobuf::internal::kEmptyString) {
    attach_data_ = new ::std::string;
  }
  attach_data_->assign(value);
}
inline void IMAllUserReq::set_attach_data(const char* value) {
  set_has_attach_data();
  if (attach_data_ == &::google::protobuf::internal::kEmptyString) {
    attach_data_ = new ::std::string;
  }
  attach_data_->assign(value);
}
inline void IMAllUserReq::set_attach_data(const void* value, size_t size) {
  set_has_attach_data();
  if (attach_data_ == &::google::protobuf::internal::kEmptyString) {
    attach_data_ = new ::std::string;
  }
  attach_data_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* IMAllUserReq::mutable_attach_data() {
  set_has_attach_data();
  if (attach_data_ == &::google::protobuf::internal::kEmptyString) {
    attach_data_ = new ::std::string;
  }
  return attach_data_;
}
inline ::std::string* IMAllUserReq::release_attach_data() {
  clear_has_attach_data();
  if (attach_data_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = attach_data_;
    attach_data_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// -------------------------------------------------------------------

// IMAllUserRsp

// required uint32 user_id = 1;
inline bool IMAllUserRsp::has_user_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void IMAllUserRsp::set_has_user_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void IMAllUserRsp::clear_has_user_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void IMAllUserRsp::clear_user_id() {
  user_id_ = 0u;
  clear_has_user_id();
}
inline ::google::protobuf::uint32 IMAllUserRsp::user_id() const {
  return user_id_;
}
inline void IMAllUserRsp::set_user_id(::google::protobuf::uint32 value) {
  set_has_user_id();
  user_id_ = value;
}

// required uint32 latest_update_time = 2;
inline bool IMAllUserRsp::has_latest_update_time() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void IMAllUserRsp::set_has_latest_update_time() {
  _has_bits_[0] |= 0x00000002u;
}
inline void IMAllUserRsp::clear_has_latest_update_time() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void IMAllUserRsp::clear_latest_update_time() {
  latest_update_time_ = 0u;
  clear_has_latest_update_time();
}
inline ::google::protobuf::uint32 IMAllUserRsp::latest_update_time() const {
  return latest_update_time_;
}
inline void IMAllUserRsp::set_latest_update_time(::google::protobuf::uint32 value) {
  set_has_latest_update_time();
  latest_update_time_ = value;
}

// repeated .IM.BaseDefine.UserInfo user_list = 3;
inline int IMAllUserRsp::user_list_size() const {
  return user_list_.size();
}
inline void IMAllUserRsp::clear_user_list() {
  user_list_.Clear();
}
inline const ::IM::BaseDefine::UserInfo& IMAllUserRsp::user_list(int index) const {
  return user_list_.Get(index);
}
inline ::IM::BaseDefine::UserInfo* IMAllUserRsp::mutable_user_list(int index) {
  return user_list_.Mutable(index);
}
inline ::IM::BaseDefine::UserInfo* IMAllUserRsp::add_user_list() {
  return user_list_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::IM::BaseDefine::UserInfo >&
IMAllUserRsp::user_list() const {
  return user_list_;
}
inline ::google::protobuf::RepeatedPtrField< ::IM::BaseDefine::UserInfo >*
IMAllUserRsp::mutable_user_list() {
  return &user_list_;
}

// optional bytes attach_data = 20;
inline bool IMAllUserRsp::has_attach_data() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void IMAllUserRsp::set_has_attach_data() {
  _has_bits_[0] |= 0x00000008u;
}
inline void IMAllUserRsp::clear_has_attach_data() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void IMAllUserRsp::clear_attach_data() {
  if (attach_data_ != &::google::protobuf::internal::kEmptyString) {
    attach_data_->clear();
  }
  clear_has_attach_data();
}
inline const ::std::string& IMAllUserRsp::attach_data() const {
  return *attach_data_;
}
inline void IMAllUserRsp::set_attach_data(const ::std::string& value) {
  set_has_attach_data();
  if (attach_data_ == &::google::protobuf::internal::kEmptyString) {
    attach_data_ = new ::std::string;
  }
  attach_data_->assign(value);
}
inline void IMAllUserRsp::set_attach_data(const char* value) {
  set_has_attach_data();
  if (attach_data_ == &::google::protobuf::internal::kEmptyString) {
    attach_data_ = new ::std::string;
  }
  attach_data_->assign(value);
}
inline void IMAllUserRsp::set_attach_data(const void* value, size_t size) {
  set_has_attach_data();
  if (attach_data_ == &::google::protobuf::internal::kEmptyString) {
    attach_data_ = new ::std::string;
  }
  attach_data_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* IMAllUserRsp::mutable_attach_data() {
  set_has_attach_data();
  if (attach_data_ == &::google::protobuf::internal::kEmptyString) {
    attach_data_ = new ::std::string;
  }
  return attach_data_;
}
inline ::std::string* IMAllUserRsp::release_attach_data() {
  clear_has_attach_data();
  if (attach_data_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = attach_data_;
    attach_data_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// -------------------------------------------------------------------

// IMUsersStatReq

// required uint32 user_id = 1;
inline bool IMUsersStatReq::has_user_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void IMUsersStatReq::set_has_user_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void IMUsersStatReq::clear_has_user_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void IMUsersStatReq::clear_user_id() {
  user_id_ = 0u;
  clear_has_user_id();
}
inline ::google::protobuf::uint32 IMUsersStatReq::user_id() const {
  return user_id_;
}
inline void IMUsersStatReq::set_user_id(::google::protobuf::uint32 value) {
  set_has_user_id();
  user_id_ = value;
}

// repeated uint32 user_id_list = 2;
inline int IMUsersStatReq::user_id_list_size() const {
  return user_id_list_.size();
}
inline void IMUsersStatReq::clear_user_id_list() {
  user_id_list_.Clear();
}
inline ::google::protobuf::uint32 IMUsersStatReq::user_id_list(int index) const {
  return user_id_list_.Get(index);
}
inline void IMUsersStatReq::set_user_id_list(int index, ::google::protobuf::uint32 value) {
  user_id_list_.Set(index, value);
}
inline void IMUsersStatReq::add_user_id_list(::google::protobuf::uint32 value) {
  user_id_list_.Add(value);
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
IMUsersStatReq::user_id_list() const {
  return user_id_list_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
IMUsersStatReq::mutable_user_id_list() {
  return &user_id_list_;
}

// optional bytes attach_data = 20;
inline bool IMUsersStatReq::has_attach_data() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void IMUsersStatReq::set_has_attach_data() {
  _has_bits_[0] |= 0x00000004u;
}
inline void IMUsersStatReq::clear_has_attach_data() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void IMUsersStatReq::clear_attach_data() {
  if (attach_data_ != &::google::protobuf::internal::kEmptyString) {
    attach_data_->clear();
  }
  clear_has_attach_data();
}
inline const ::std::string& IMUsersStatReq::attach_data() const {
  return *attach_data_;
}
inline void IMUsersStatReq::set_attach_data(const ::std::string& value) {
  set_has_attach_data();
  if (attach_data_ == &::google::protobuf::internal::kEmptyString) {
    attach_data_ = new ::std::string;
  }
  attach_data_->assign(value);
}
inline void IMUsersStatReq::set_attach_data(const char* value) {
  set_has_attach_data();
  if (attach_data_ == &::google::protobuf::internal::kEmptyString) {
    attach_data_ = new ::std::string;
  }
  attach_data_->assign(value);
}
inline void IMUsersStatReq::set_attach_data(const void* value, size_t size) {
  set_has_attach_data();
  if (attach_data_ == &::google::protobuf::internal::kEmptyString) {
    attach_data_ = new ::std::string;
  }
  attach_data_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* IMUsersStatReq::mutable_attach_data() {
  set_has_attach_data();
  if (attach_data_ == &::google::protobuf::internal::kEmptyString) {
    attach_data_ = new ::std::string;
  }
  return attach_data_;
}
inline ::std::string* IMUsersStatReq::release_attach_data() {
  clear_has_attach_data();
  if (attach_data_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = attach_data_;
    attach_data_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// -------------------------------------------------------------------

// IMUsersStatRsp

// required uint32 user_id = 1;
inline bool IMUsersStatRsp::has_user_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void IMUsersStatRsp::set_has_user_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void IMUsersStatRsp::clear_has_user_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void IMUsersStatRsp::clear_user_id() {
  user_id_ = 0u;
  clear_has_user_id();
}
inline ::google::protobuf::uint32 IMUsersStatRsp::user_id() const {
  return user_id_;
}
inline void IMUsersStatRsp::set_user_id(::google::protobuf::uint32 value) {
  set_has_user_id();
  user_id_ = value;
}

// repeated .IM.BaseDefine.UserStat user_stat_list = 2;
inline int IMUsersStatRsp::user_stat_list_size() const {
  return user_stat_list_.size();
}
inline void IMUsersStatRsp::clear_user_stat_list() {
  user_stat_list_.Clear();
}
inline const ::IM::BaseDefine::UserStat& IMUsersStatRsp::user_stat_list(int index) const {
  return user_stat_list_.Get(index);
}
inline ::IM::BaseDefine::UserStat* IMUsersStatRsp::mutable_user_stat_list(int index) {
  return user_stat_list_.Mutable(index);
}
inline ::IM::BaseDefine::UserStat* IMUsersStatRsp::add_user_stat_list() {
  return user_stat_list_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::IM::BaseDefine::UserStat >&
IMUsersStatRsp::user_stat_list() const {
  return user_stat_list_;
}
inline ::google::protobuf::RepeatedPtrField< ::IM::BaseDefine::UserStat >*
IMUsersStatRsp::mutable_user_stat_list() {
  return &user_stat_list_;
}

// optional bytes attach_data = 20;
inline bool IMUsersStatRsp::has_attach_data() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void IMUsersStatRsp::set_has_attach_data() {
  _has_bits_[0] |= 0x00000004u;
}
inline void IMUsersStatRsp::clear_has_attach_data() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void IMUsersStatRsp::clear_attach_data() {
  if (attach_data_ != &::google::protobuf::internal::kEmptyString) {
    attach_data_->clear();
  }
  clear_has_attach_data();
}
inline const ::std::string& IMUsersStatRsp::attach_data() const {
  return *attach_data_;
}
inline void IMUsersStatRsp::set_attach_data(const ::std::string& value) {
  set_has_attach_data();
  if (attach_data_ == &::google::protobuf::internal::kEmptyString) {
    attach_data_ = new ::std::string;
  }
  attach_data_->assign(value);
}
inline void IMUsersStatRsp::set_attach_data(const char* value) {
  set_has_attach_data();
  if (attach_data_ == &::google::protobuf::internal::kEmptyString) {
    attach_data_ = new ::std::string;
  }
  attach_data_->assign(value);
}
inline void IMUsersStatRsp::set_attach_data(const void* value, size_t size) {
  set_has_attach_data();
  if (attach_data_ == &::google::protobuf::internal::kEmptyString) {
    attach_data_ = new ::std::string;
  }
  attach_data_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* IMUsersStatRsp::mutable_attach_data() {
  set_has_attach_data();
  if (attach_data_ == &::google::protobuf::internal::kEmptyString) {
    attach_data_ = new ::std::string;
  }
  return attach_data_;
}
inline ::std::string* IMUsersStatRsp::release_attach_data() {
  clear_has_attach_data();
  if (attach_data_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = attach_data_;
    attach_data_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// -------------------------------------------------------------------

// IMChangeAvatarReq

// required uint32 user_id = 1;
inline bool IMChangeAvatarReq::has_user_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void IMChangeAvatarReq::set_has_user_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void IMChangeAvatarReq::clear_has_user_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void IMChangeAvatarReq::clear_user_id() {
  user_id_ = 0u;
  clear_has_user_id();
}
inline ::google::protobuf::uint32 IMChangeAvatarReq::user_id() const {
  return user_id_;
}
inline void IMChangeAvatarReq::set_user_id(::google::protobuf::uint32 value) {
  set_has_user_id();
  user_id_ = value;
}

// required string avatar_url = 2;
inline bool IMChangeAvatarReq::has_avatar_url() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void IMChangeAvatarReq::set_has_avatar_url() {
  _has_bits_[0] |= 0x00000002u;
}
inline void IMChangeAvatarReq::clear_has_avatar_url() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void IMChangeAvatarReq::clear_avatar_url() {
  if (avatar_url_ != &::google::protobuf::internal::kEmptyString) {
    avatar_url_->clear();
  }
  clear_has_avatar_url();
}
inline const ::std::string& IMChangeAvatarReq::avatar_url() const {
  return *avatar_url_;
}
inline void IMChangeAvatarReq::set_avatar_url(const ::std::string& value) {
  set_has_avatar_url();
  if (avatar_url_ == &::google::protobuf::internal::kEmptyString) {
    avatar_url_ = new ::std::string;
  }
  avatar_url_->assign(value);
}
inline void IMChangeAvatarReq::set_avatar_url(const char* value) {
  set_has_avatar_url();
  if (avatar_url_ == &::google::protobuf::internal::kEmptyString) {
    avatar_url_ = new ::std::string;
  }
  avatar_url_->assign(value);
}
inline void IMChangeAvatarReq::set_avatar_url(const char* value, size_t size) {
  set_has_avatar_url();
  if (avatar_url_ == &::google::protobuf::internal::kEmptyString) {
    avatar_url_ = new ::std::string;
  }
  avatar_url_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* IMChangeAvatarReq::mutable_avatar_url() {
  set_has_avatar_url();
  if (avatar_url_ == &::google::protobuf::internal::kEmptyString) {
    avatar_url_ = new ::std::string;
  }
  return avatar_url_;
}
inline ::std::string* IMChangeAvatarReq::release_avatar_url() {
  clear_has_avatar_url();
  if (avatar_url_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = avatar_url_;
    avatar_url_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional bytes attach_data = 20;
inline bool IMChangeAvatarReq::has_attach_data() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void IMChangeAvatarReq::set_has_attach_data() {
  _has_bits_[0] |= 0x00000004u;
}
inline void IMChangeAvatarReq::clear_has_attach_data() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void IMChangeAvatarReq::clear_attach_data() {
  if (attach_data_ != &::google::protobuf::internal::kEmptyString) {
    attach_data_->clear();
  }
  clear_has_attach_data();
}
inline const ::std::string& IMChangeAvatarReq::attach_data() const {
  return *attach_data_;
}
inline void IMChangeAvatarReq::set_attach_data(const ::std::string& value) {
  set_has_attach_data();
  if (attach_data_ == &::google::protobuf::internal::kEmptyString) {
    attach_data_ = new ::std::string;
  }
  attach_data_->assign(value);
}
inline void IMChangeAvatarReq::set_attach_data(const char* value) {
  set_has_attach_data();
  if (attach_data_ == &::google::protobuf::internal::kEmptyString) {
    attach_data_ = new ::std::string;
  }
  attach_data_->assign(value);
}
inline void IMChangeAvatarReq::set_attach_data(const void* value, size_t size) {
  set_has_attach_data();
  if (attach_data_ == &::google::protobuf::internal::kEmptyString) {
    attach_data_ = new ::std::string;
  }
  attach_data_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* IMChangeAvatarReq::mutable_attach_data() {
  set_has_attach_data();
  if (attach_data_ == &::google::protobuf::internal::kEmptyString) {
    attach_data_ = new ::std::string;
  }
  return attach_data_;
}
inline ::std::string* IMChangeAvatarReq::release_attach_data() {
  clear_has_attach_data();
  if (attach_data_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = attach_data_;
    attach_data_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// -------------------------------------------------------------------

// IMChangeAvatarRsp

// required uint32 user_id = 1;
inline bool IMChangeAvatarRsp::has_user_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void IMChangeAvatarRsp::set_has_user_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void IMChangeAvatarRsp::clear_has_user_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void IMChangeAvatarRsp::clear_user_id() {
  user_id_ = 0u;
  clear_has_user_id();
}
inline ::google::protobuf::uint32 IMChangeAvatarRsp::user_id() const {
  return user_id_;
}
inline void IMChangeAvatarRsp::set_user_id(::google::protobuf::uint32 value) {
  set_has_user_id();
  user_id_ = value;
}

// required uint32 result_code = 2;
inline bool IMChangeAvatarRsp::has_result_code() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void IMChangeAvatarRsp::set_has_result_code() {
  _has_bits_[0] |= 0x00000002u;
}
inline void IMChangeAvatarRsp::clear_has_result_code() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void IMChangeAvatarRsp::clear_result_code() {
  result_code_ = 0u;
  clear_has_result_code();
}
inline ::google::protobuf::uint32 IMChangeAvatarRsp::result_code() const {
  return result_code_;
}
inline void IMChangeAvatarRsp::set_result_code(::google::protobuf::uint32 value) {
  set_has_result_code();
  result_code_ = value;
}

// optional bytes attach_data = 20;
inline bool IMChangeAvatarRsp::has_attach_data() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void IMChangeAvatarRsp::set_has_attach_data() {
  _has_bits_[0] |= 0x00000004u;
}
inline void IMChangeAvatarRsp::clear_has_attach_data() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void IMChangeAvatarRsp::clear_attach_data() {
  if (attach_data_ != &::google::protobuf::internal::kEmptyString) {
    attach_data_->clear();
  }
  clear_has_attach_data();
}
inline const ::std::string& IMChangeAvatarRsp::attach_data() const {
  return *attach_data_;
}
inline void IMChangeAvatarRsp::set_attach_data(const ::std::string& value) {
  set_has_attach_data();
  if (attach_data_ == &::google::protobuf::internal::kEmptyString) {
    attach_data_ = new ::std::string;
  }
  attach_data_->assign(value);
}
inline void IMChangeAvatarRsp::set_attach_data(const char* value) {
  set_has_attach_data();
  if (attach_data_ == &::google::protobuf::internal::kEmptyString) {
    attach_data_ = new ::std::string;
  }
  attach_data_->assign(value);
}
inline void IMChangeAvatarRsp::set_attach_data(const void* value, size_t size) {
  set_has_attach_data();
  if (attach_data_ == &::google::protobuf::internal::kEmptyString) {
    attach_data_ = new ::std::string;
  }
  attach_data_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* IMChangeAvatarRsp::mutable_attach_data() {
  set_has_attach_data();
  if (attach_data_ == &::google::protobuf::internal::kEmptyString) {
    attach_data_ = new ::std::string;
  }
  return attach_data_;
}
inline ::std::string* IMChangeAvatarRsp::release_attach_data() {
  clear_has_attach_data();
  if (attach_data_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = attach_data_;
    attach_data_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// -------------------------------------------------------------------

// IMPCLoginStatusNotify

// required uint32 user_id = 1;
inline bool IMPCLoginStatusNotify::has_user_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void IMPCLoginStatusNotify::set_has_user_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void IMPCLoginStatusNotify::clear_has_user_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void IMPCLoginStatusNotify::clear_user_id() {
  user_id_ = 0u;
  clear_has_user_id();
}
inline ::google::protobuf::uint32 IMPCLoginStatusNotify::user_id() const {
  return user_id_;
}
inline void IMPCLoginStatusNotify::set_user_id(::google::protobuf::uint32 value) {
  set_has_user_id();
  user_id_ = value;
}

// required .IM.BaseDefine.UserStatType login_stat = 2;
inline bool IMPCLoginStatusNotify::has_login_stat() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void IMPCLoginStatusNotify::set_has_login_stat() {
  _has_bits_[0] |= 0x00000002u;
}
inline void IMPCLoginStatusNotify::clear_has_login_stat() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void IMPCLoginStatusNotify::clear_login_stat() {
  login_stat_ = 1;
  clear_has_login_stat();
}
inline IM::BaseDefine::UserStatType IMPCLoginStatusNotify::login_stat() const {
  return static_cast< IM::BaseDefine::UserStatType >(login_stat_);
}
inline void IMPCLoginStatusNotify::set_login_stat(IM::BaseDefine::UserStatType value) {
  GOOGLE_DCHECK(IM::BaseDefine::UserStatType_IsValid(value));
  set_has_login_stat();
  login_stat_ = value;
}

// -------------------------------------------------------------------

// IMRemoveSessionNotify

// required uint32 user_id = 1;
inline bool IMRemoveSessionNotify::has_user_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void IMRemoveSessionNotify::set_has_user_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void IMRemoveSessionNotify::clear_has_user_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void IMRemoveSessionNotify::clear_user_id() {
  user_id_ = 0u;
  clear_has_user_id();
}
inline ::google::protobuf::uint32 IMRemoveSessionNotify::user_id() const {
  return user_id_;
}
inline void IMRemoveSessionNotify::set_user_id(::google::protobuf::uint32 value) {
  set_has_user_id();
  user_id_ = value;
}

// required .IM.BaseDefine.SessionType session_type = 2;
inline bool IMRemoveSessionNotify::has_session_type() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void IMRemoveSessionNotify::set_has_session_type() {
  _has_bits_[0] |= 0x00000002u;
}
inline void IMRemoveSessionNotify::clear_has_session_type() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void IMRemoveSessionNotify::clear_session_type() {
  session_type_ = 1;
  clear_has_session_type();
}
inline IM::BaseDefine::SessionType IMRemoveSessionNotify::session_type() const {
  return static_cast< IM::BaseDefine::SessionType >(session_type_);
}
inline void IMRemoveSessionNotify::set_session_type(IM::BaseDefine::SessionType value) {
  GOOGLE_DCHECK(IM::BaseDefine::SessionType_IsValid(value));
  set_has_session_type();
  session_type_ = value;
}

// required uint32 session_id = 3;
inline bool IMRemoveSessionNotify::has_session_id() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void IMRemoveSessionNotify::set_has_session_id() {
  _has_bits_[0] |= 0x00000004u;
}
inline void IMRemoveSessionNotify::clear_has_session_id() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void IMRemoveSessionNotify::clear_session_id() {
  session_id_ = 0u;
  clear_has_session_id();
}
inline ::google::protobuf::uint32 IMRemoveSessionNotify::session_id() const {
  return session_id_;
}
inline void IMRemoveSessionNotify::set_session_id(::google::protobuf::uint32 value) {
  set_has_session_id();
  session_id_ = value;
}

// -------------------------------------------------------------------

// IMDepartmentReq

// required uint32 user_id = 1;
inline bool IMDepartmentReq::has_user_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void IMDepartmentReq::set_has_user_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void IMDepartmentReq::clear_has_user_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void IMDepartmentReq::clear_user_id() {
  user_id_ = 0u;
  clear_has_user_id();
}
inline ::google::protobuf::uint32 IMDepartmentReq::user_id() const {
  return user_id_;
}
inline void IMDepartmentReq::set_user_id(::google::protobuf::uint32 value) {
  set_has_user_id();
  user_id_ = value;
}

// required uint32 latest_update_time = 2;
inline bool IMDepartmentReq::has_latest_update_time() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void IMDepartmentReq::set_has_latest_update_time() {
  _has_bits_[0] |= 0x00000002u;
}
inline void IMDepartmentReq::clear_has_latest_update_time() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void IMDepartmentReq::clear_latest_update_time() {
  latest_update_time_ = 0u;
  clear_has_latest_update_time();
}
inline ::google::protobuf::uint32 IMDepartmentReq::latest_update_time() const {
  return latest_update_time_;
}
inline void IMDepartmentReq::set_latest_update_time(::google::protobuf::uint32 value) {
  set_has_latest_update_time();
  latest_update_time_ = value;
}

// optional bytes attach_data = 20;
inline bool IMDepartmentReq::has_attach_data() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void IMDepartmentReq::set_has_attach_data() {
  _has_bits_[0] |= 0x00000004u;
}
inline void IMDepartmentReq::clear_has_attach_data() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void IMDepartmentReq::clear_attach_data() {
  if (attach_data_ != &::google::protobuf::internal::kEmptyString) {
    attach_data_->clear();
  }
  clear_has_attach_data();
}
inline const ::std::string& IMDepartmentReq::attach_data() const {
  return *attach_data_;
}
inline void IMDepartmentReq::set_attach_data(const ::std::string& value) {
  set_has_attach_data();
  if (attach_data_ == &::google::protobuf::internal::kEmptyString) {
    attach_data_ = new ::std::string;
  }
  attach_data_->assign(value);
}
inline void IMDepartmentReq::set_attach_data(const char* value) {
  set_has_attach_data();
  if (attach_data_ == &::google::protobuf::internal::kEmptyString) {
    attach_data_ = new ::std::string;
  }
  attach_data_->assign(value);
}
inline void IMDepartmentReq::set_attach_data(const void* value, size_t size) {
  set_has_attach_data();
  if (attach_data_ == &::google::protobuf::internal::kEmptyString) {
    attach_data_ = new ::std::string;
  }
  attach_data_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* IMDepartmentReq::mutable_attach_data() {
  set_has_attach_data();
  if (attach_data_ == &::google::protobuf::internal::kEmptyString) {
    attach_data_ = new ::std::string;
  }
  return attach_data_;
}
inline ::std::string* IMDepartmentReq::release_attach_data() {
  clear_has_attach_data();
  if (attach_data_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = attach_data_;
    attach_data_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// -------------------------------------------------------------------

// IMDepartmentRsp

// required uint32 user_id = 1;
inline bool IMDepartmentRsp::has_user_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void IMDepartmentRsp::set_has_user_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void IMDepartmentRsp::clear_has_user_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void IMDepartmentRsp::clear_user_id() {
  user_id_ = 0u;
  clear_has_user_id();
}
inline ::google::protobuf::uint32 IMDepartmentRsp::user_id() const {
  return user_id_;
}
inline void IMDepartmentRsp::set_user_id(::google::protobuf::uint32 value) {
  set_has_user_id();
  user_id_ = value;
}

// required uint32 latest_update_time = 2;
inline bool IMDepartmentRsp::has_latest_update_time() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void IMDepartmentRsp::set_has_latest_update_time() {
  _has_bits_[0] |= 0x00000002u;
}
inline void IMDepartmentRsp::clear_has_latest_update_time() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void IMDepartmentRsp::clear_latest_update_time() {
  latest_update_time_ = 0u;
  clear_has_latest_update_time();
}
inline ::google::protobuf::uint32 IMDepartmentRsp::latest_update_time() const {
  return latest_update_time_;
}
inline void IMDepartmentRsp::set_latest_update_time(::google::protobuf::uint32 value) {
  set_has_latest_update_time();
  latest_update_time_ = value;
}

// repeated .IM.BaseDefine.DepartInfo dept_list = 3;
inline int IMDepartmentRsp::dept_list_size() const {
  return dept_list_.size();
}
inline void IMDepartmentRsp::clear_dept_list() {
  dept_list_.Clear();
}
inline const ::IM::BaseDefine::DepartInfo& IMDepartmentRsp::dept_list(int index) const {
  return dept_list_.Get(index);
}
inline ::IM::BaseDefine::DepartInfo* IMDepartmentRsp::mutable_dept_list(int index) {
  return dept_list_.Mutable(index);
}
inline ::IM::BaseDefine::DepartInfo* IMDepartmentRsp::add_dept_list() {
  return dept_list_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::IM::BaseDefine::DepartInfo >&
IMDepartmentRsp::dept_list() const {
  return dept_list_;
}
inline ::google::protobuf::RepeatedPtrField< ::IM::BaseDefine::DepartInfo >*
IMDepartmentRsp::mutable_dept_list() {
  return &dept_list_;
}

// optional bytes attach_data = 20;
inline bool IMDepartmentRsp::has_attach_data() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void IMDepartmentRsp::set_has_attach_data() {
  _has_bits_[0] |= 0x00000008u;
}
inline void IMDepartmentRsp::clear_has_attach_data() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void IMDepartmentRsp::clear_attach_data() {
  if (attach_data_ != &::google::protobuf::internal::kEmptyString) {
    attach_data_->clear();
  }
  clear_has_attach_data();
}
inline const ::std::string& IMDepartmentRsp::attach_data() const {
  return *attach_data_;
}
inline void IMDepartmentRsp::set_attach_data(const ::std::string& value) {
  set_has_attach_data();
  if (attach_data_ == &::google::protobuf::internal::kEmptyString) {
    attach_data_ = new ::std::string;
  }
  attach_data_->assign(value);
}
inline void IMDepartmentRsp::set_attach_data(const char* value) {
  set_has_attach_data();
  if (attach_data_ == &::google::protobuf::internal::kEmptyString) {
    attach_data_ = new ::std::string;
  }
  attach_data_->assign(value);
}
inline void IMDepartmentRsp::set_attach_data(const void* value, size_t size) {
  set_has_attach_data();
  if (attach_data_ == &::google::protobuf::internal::kEmptyString) {
    attach_data_ = new ::std::string;
  }
  attach_data_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* IMDepartmentRsp::mutable_attach_data() {
  set_has_attach_data();
  if (attach_data_ == &::google::protobuf::internal::kEmptyString) {
    attach_data_ = new ::std::string;
  }
  return attach_data_;
}
inline ::std::string* IMDepartmentRsp::release_attach_data() {
  clear_has_attach_data();
  if (attach_data_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = attach_data_;
    attach_data_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace Buddy
}  // namespace IM

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_IM_2eBuddy_2eproto__INCLUDED
